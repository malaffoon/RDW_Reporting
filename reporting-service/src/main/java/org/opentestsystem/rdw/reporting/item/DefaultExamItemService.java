package org.opentestsystem.rdw.reporting.item;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.ByteStreams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.net.URLConnection;
import java.util.Base64;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.StringJoiner;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.IntStream;
import org.opentestsystem.rdw.reporting.artifact.ArtifactRepository;

import static com.google.common.collect.ImmutableList.toImmutableList;
import static org.apache.commons.lang3.StringUtils.trimToNull;

@Service
class DefaultExamItemService implements ExamItemService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultExamItemService.class);
    private static final ImmutableSet ANSWER_KEY_FORMATS = ImmutableSet.of("EBSR", "MS", "MC");
    private static final Pattern IMAGE_PATTERN = Pattern.compile("<img[^>]+src\\s*=\\s*['\"]([^'\"]+)['\"][^>]*>");

    private final ArtifactRepository artifactRepository;

    private DocumentBuilder documentBuilder;
    private XPathExpression rubricListPath;
    private XPathExpression answerKeyPath;
    private XPathExpression answerKey2Path;
    private XPathExpression rubricPath;
    private XPathExpression samplePath;
    private XPathExpression valuePath;
    private XPathExpression scorePointPath;
    private XPathExpression sampleContentPath;
    private XPathExpression formatPath;

    @Autowired
    DefaultExamItemService(final ArtifactRepository artifactRepository) {
        this.artifactRepository = artifactRepository;

        try {
            final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
            documentBuilderFactory.setValidating(false);
            documentBuilderFactory.setIgnoringComments(false);
            documentBuilderFactory.setIgnoringElementContentWhitespace(true);
            documentBuilderFactory.setNamespaceAware(true);
            this.documentBuilder = documentBuilderFactory.newDocumentBuilder();

            final XPath xPath = XPathFactory.newInstance().newXPath();
            this.rubricListPath = xPath.compile("/itemrelease/item/content/rubriclist");
            this.answerKeyPath = xPath.compile("/itemrelease/item/attriblist/attrib[@attid='itm_att_Answer Key']");
            this.answerKey2Path = xPath.compile("/itemrelease/item/attriblist/attrib[@attid='itm_att_Answer Key (Part II)']");
            this.rubricPath = xPath.compile("./rubric");
            this.samplePath = xPath.compile("./samplelist/sample");
            this.valuePath = xPath.compile("./val");
            this.scorePointPath = xPath.compile("./@scorepoint");
            this.sampleContentPath = xPath.compile("./samplecontent");
            this.formatPath = xPath.compile("/itemrelease/item/@format");
        } catch (final Exception exception) {
            logger.error("Error initializing {}", getClass().getName(), exception);
        }
    }

    @Override
    public ExamItemScoringGuide getScoringGuide(final String id) {
        try {
            return getExamItemSolution(getXmlDocument(id), id);
        }
        catch(SAXException exception) {
            logger.error(String.format("SAXException while trying to read the item xml: %s", id), exception);
            throw new RuntimeException(String.format("Error reading the xml for item: %s", id), exception);
        }
        catch (final IOException | XPathExpressionException exception) {
            throw new NoSuchElementException(String.format("Rubric/Exemplar data is not available for item: %s", id));
        }
    }

    // DocumentBuilder.parse is not thread-safe: https://stackoverflow.com/questions/12455602/is-documentbuilder-thread-safe
    private synchronized Document getXmlDocument(final String id) throws IOException, SAXException {
        return documentBuilder.parse(artifactRepository.getItemXml(id));
    }

    private ExamItemScoringGuide getExamItemSolution(final Node root, final String id) throws XPathExpressionException {
        final Node node = (Node) rubricListPath.evaluate(root, XPathConstants.NODE);
        return ExamItemScoringGuide.builder()
                .answerKey(getAnswerKey(root))
                .rubrics(safeList(node, rubricPath, n -> createRubric(n, id), ImmutableList.of()))
                .exemplars(safeList(node, samplePath, n -> createExemplar(n, id), ImmutableList.of()))
                .build();
    }

    private AnswerKey getAnswerKey(final Node root) {
        // only MC, MS, EBSR will have valid answer key elements
        if (!ANSWER_KEY_FORMATS.contains(safeValue(root, formatPath).toUpperCase())) {
            return null;
        }

        // extract the two answer key values
        final String answerKey = trimToNull(safeValue(root, answerKeyPath, n -> safeValue(n, valuePath), null));
        final String answerKey2 = trimToNull(safeValue(root, answerKey2Path, n -> safeValue(n, valuePath), null));
        if (answerKey == null && answerKey2 == null) {
            return null;
        }

        final StringJoiner joiner = new StringJoiner(";");
        if (answerKey != null) {
            joiner.add(answerKey);
        }
        if (answerKey2 != null) {
            joiner.add(answerKey2);
        }

        // empirically the name and description for these items are always the same, or garbage
        // so don't bother parsing for them ...
        return AnswerKey.builder()
                .name("Answer Key")
                .value(joiner.toString())
                .build();
    }

    private ScoringCriterion createRubric(final Node node, final String id) {
        return ScoringCriterion.builder()
                .scorepoint(safeValue(node, scorePointPath))
                .template(encodeImages(safeValue(node, valuePath), id))
                .build();
    }

    private ScoringCriterion createExemplar(final Node node, final String id) {
        return ScoringCriterion.builder()
                .scorepoint(safeValue(node, scorePointPath))
                .template(encodeImages(safeValue(node, sampleContentPath), id))
                .build();
    }

    private String encodeImages(final String html, final String id) {
        String result = html;
        final Matcher matcher = IMAGE_PATTERN.matcher(html);
        while (matcher.find()) {
            final String imagePath = matcher.group(1);
            try {
                final String base64Image = Base64.getEncoder()
                        .encodeToString(ByteStreams.toByteArray(
                                artifactRepository.getArtifactFromItemDirectory(id, imagePath)
                        ));

                final String mimeType = URLConnection.guessContentTypeFromName(imagePath);
                result = result.replace(imagePath, "data:" + mimeType + ";base64," + base64Image);
            } catch (final IOException exception) {
                logger.warn("Unable to find image \"{}\" for item: {}", imagePath, id, exception);
            }
            matcher.end();
        }
        return result;
    }

    private String safeValue(final Node node, final XPathExpression expression) {
        return safeValue(node, expression, n -> n.getNodeType() == Node.ATTRIBUTE_NODE ? n.getNodeValue() : n.getTextContent(), "");
    }

    private <T> T safeValue(final Node start, final XPathExpression expression, final Function<Node, T> mapper, final T defaultValue) {
        if (start == null) {
            return defaultValue;
        }
        final Node node;
        try {
            node = (Node) expression.evaluate(start, XPathConstants.NODE);
        } catch (final XPathExpressionException exception) {
            return defaultValue;
        }
        if (node == null) {
            return defaultValue;
        }
        return mapper.apply(node);
    }

    private <T> List<T> safeList(final Node start, final XPathExpression expression, final Function<Node, T> mapper, final List<T> defaultValue) {
        if (start == null) {
            return defaultValue;
        }
        final NodeList nodes;
        try {
            nodes = (NodeList) expression.evaluate(start, XPathConstants.NODESET);
        } catch (final XPathExpressionException exception) {
            return defaultValue;
        }
        if (nodes == null) {
            return defaultValue;
        }
        return IntStream
                .range(0, nodes.getLength())
                .mapToObj(nodes::item)
                .map(mapper)
                .collect(toImmutableList());
    }

}
