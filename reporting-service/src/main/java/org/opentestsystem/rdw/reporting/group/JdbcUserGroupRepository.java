package org.opentestsystem.rdw.reporting.group;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import static com.google.common.collect.Sets.newHashSet;
import static java.util.stream.Collectors.toSet;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.safeSplit;


@Repository
public class JdbcUserGroupRepository implements UserGroupRepository {

    private final NamedParameterJdbcTemplate template;
    private final ReportingSystemSettings settings;

    @Value("${sql.teacherGroup.findAllByUsername}")
    private String findAllQuery;

    @Value("${sql.teacherGroup.findOneByUsernameAndId}")
    private String findOneQuery;

    @Value("${sql.teacherGroup.create}")
    private String createQuery;

    @Value("${sql.teacherGroup.update}")
    private String updateQuery;

    @Value("${sql.teacherGroup.delete}")
    private String deleteQuery;

    @Value("${sql.teacherGroupMembership.findAllStudentIdsByGroupId}")
    private String findAllMembershipStudentIdsByGroupIdQuery;

    @Value("${sql.teacherGroupMembership.create}")
    private String createMembershipQuery;

    @Value("${sql.teacherGroupMembership.delete}")
    private String deleteMembershipQuery;

    @Value("${sql.teacherGroupMembership.deleteAllByGroupId}")
    private String deleteMembershipByGroupIdQuery;


    JdbcUserGroupRepository(@Qualifier("writableJdbcTemplate") final NamedParameterJdbcTemplate template,
                            final ReportingSystemSettings settings) {
        this.template = template;
        this.settings = settings;
    }

    @Override
    public List<Group> findAll(final PermissionSource permissionSource) {
        return template.query(
                findAllQuery,
                new MapSqlParameterSource("user_login", permissionSource.getUsername()),
                (row, index) -> Group.builder()
                        .id(row.getLong("id"))
                        .name(row.getString("name"))
                        .subjectCode(row.getString("subject_code")) // filler support for groups table
                        .subjectCodes(decodeSubjects(row.getString("subject_code")))
                        .studentCount(row.getInt("student_count"))
                        .userCreated(true)
                        .build()
        );
    }

    @Override
    public Group findOne(final PermissionSource permissionSource, final long groupId) {
        try {
            return template.queryForObject(
                    findOneQuery,
                    new MapSqlParameterSource()
                            .addValue("user_login", permissionSource.getUsername())
                            .addValue("id", groupId),
                    (row, index) -> {
                        final List<String> studentIdStrings = safeSplit(row.getString("student_ids"), "|");
                        final Set<Long> studentIds = studentIdStrings != null
                                ? studentIdStrings.stream().map(Long::valueOf).collect(toSet())
                                : newHashSet();

                        return Group.builder()
                                .id(row.getLong("id"))
                                .name(row.getString("name"))
                                .subjectCodes(decodeSubjects(row.getString("subject_code")))
                                .studentIds(studentIds)
                                .userCreated(true)
                                .build();
                    }
            );
        } catch (final EmptyResultDataAccessException exception) {
            return null;
        }
    }

    @Override
    @Transactional
    public Group create(final String username, final Group group) {
        final KeyHolder keyHolder = new GeneratedKeyHolder();
        template.update(
                createQuery,
                new MapSqlParameterSource()
                        .addValue("user_login", username)
                        .addValue("name", group.getName())
                        .addValue("school_year", settings.getSchoolYear())
                        .addValue("subject_code", encodeSubjects(group.getSubjectCodes())),
                keyHolder
        );

        final long groupId = keyHolder.getKey().longValue();

        template.batchUpdate(
                createMembershipQuery,
                group.getStudentIds().stream()
                        .map(studentId -> new MapSqlParameterSource()
                                .addValue("group_id", groupId)
                                .addValue("student_id", studentId)
                        )
                        .toArray(MapSqlParameterSource[]::new));

        return group.copy()
                .id(groupId)
                .build();
    }

    @Override
    @Transactional
    public void update(final Group group) {

        final Set<Long> currentStudentIds = ImmutableSet.copyOf(template.queryForList(
                findAllMembershipStudentIdsByGroupIdQuery,
                new MapSqlParameterSource("group_id", group.getId()),
                Long.class
        ));

        final Set<Long> newStudentIds = group.getStudentIds();
        final Set<Long> removedStudentIds = Sets.difference(currentStudentIds, newStudentIds);
        final Set<Long> addedStudentIds = Sets.difference(newStudentIds, currentStudentIds);

        if (!removedStudentIds.isEmpty()) {
            template.batchUpdate(
                    deleteMembershipQuery,
                    toSqlParameterSources(removedStudentIds, group.getId()));
        }

        if (!addedStudentIds.isEmpty()) {
            template.batchUpdate(
                    createMembershipQuery,
                    toSqlParameterSources(addedStudentIds, group.getId()));
        }

        template.update(
                updateQuery,
                new MapSqlParameterSource()
                        .addValue("id", group.getId())
                        .addValue("name", group.getName())
                        .addValue("subject_code", encodeSubjects(group.getSubjectCodes())));

    }

    @Override
    @Transactional
    public void delete(final long groupId) {
        template.update(
                deleteMembershipByGroupIdQuery,
                new MapSqlParameterSource("group_id", groupId));
        template.update(
                deleteQuery,
                new MapSqlParameterSource("id", groupId));
    }

    private SqlParameterSource[] toSqlParameterSources(final Collection<Long> studentIds, final long groupId) {
        return studentIds.stream()
                .map(studentId -> new MapSqlParameterSource()
                        .addValue("group_id", groupId)
                        .addValue("student_id", studentId)
                )
                .toArray(MapSqlParameterSource[]::new);
    }

    /**
     * Transforms subject codes into single subject code for storage
     * Currently multiple subjects aren't supported.
     *
     * @param subjectCodes the subject codes to transform
     * @return null if subjectCodes is null, empty or contains multiple elements. The single subject code element if present
     */
    private String encodeSubjects(final Set<String> subjectCodes) {
        if (subjectCodes == null
                || subjectCodes.isEmpty()
                || subjectCodes.size() > 1) {
            return null;
        }
        return subjectCodes.iterator().next();
    }

    /**
     * Transforms single subject code into a collection of one subject code or null if the subject code is null
     *
     * @param subjectCode the subject code to transform
     * @return null if the subject code is null or a set of the single subject code if present
     */
    private Set<String> decodeSubjects(final String subjectCode) {
        if (subjectCode == null) {
            return null;
        }
        return newHashSet(subjectCode);
    }

}
