package org.opentestsystem.rdw.reporting.common.jdbc;

import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.rangeClosed;

/**
 * Holds common methods for preparing SQL queries and parsing their results
 */
public class QueryUtils {

    public static final List<Long> UNMATCHABLE_IDS = ImmutableList.of(-1L);


    // Redshift is caching the query execution plan much better when SQL has the same number of parameters in the IN clause.
    // The best guess based on examining the execution plan is that the optimizer converts IN into ORs, and hence it sees it as
    // a different query. Optimizer also removes duplicate values from the IN, so to trick it we are padding each IN to a fixed size with
    // distinct negative values.
    //
    // tests use negative numbers, to avoid conflict we start with a bigger number
    private static final List<Integer> UNMATCHABLE_INT_DISTINCT_IDS = rangeClosed(300, 400).boxed().map(r -> (-1 * r)).collect(toList());
    private static final List<Long> UNMATCHABLE_LONG_DISTINCT_IDS = rangeClosed(300, 400).boxed().map(r -> (long) (-1 * r)).collect(toList());


    private QueryUtils() {
    }

    /**
     * Returns the given collection or the given default collection if the collection is null or empty
     *
     * @param collection   the collection to test null and empty for
     * @param defaultValue the collection to return if the given collection is null or empty
     * @param <T>          the collection element type
     * @return the given collection or the given default collection if the collection is null or empty
     */
    public static <T> Collection<T> nullOrEmptyToDefault(final Collection<T> collection, final Collection<T> defaultValue) {
        if (collection == null || collection.isEmpty()) {
            return defaultValue;
        }
        return collection;
    }

    /**
     * Returns the given value or null if the last column lookup resulted in a null value.
     * This is a workaround for two things: typecasting the return value of {@link ResultSet#getObject(String)} for getNullable columns
     * <ol>
     * <li>{@link ResultSet#getLong(String)} and other primitive type lookups will turn null into the default values
     * (e.g. null boolean will be false, null long will be 0)</li>
     * <li>Type casting the result of {@link ResultSet#getLong(String)} can result in type cast exceptions if the
     * database driver returns an Integer and you cast to Long.</li>
     * </ol>
     *
     * @param resultSet the row of data which will be checked for null
     * @param value     the result of the row lookup (e.g. resultSet.getLong("column_name"))
     * @param <T>       the type of the provided value
     * @return the value or null if the column lookup was null
     * @throws SQLException if database error or result set closed
     */
    public static <T> T getNullable(final ResultSet resultSet, final T value) throws SQLException {
        return resultSet.wasNull() ? null : value;
    }

    /**
     * Splits the given delimited values string with the given delimiting character.
     * If the given delimited values string is null or empty it will return null
     *
     * @param delimitedValues string of delimited values
     * @param delimiter       string delimiting the values
     * @return the delimited values split or null if the delimited values are null or empty
     */
    public static List<String> safeSplit(final String delimitedValues, final String delimiter) {
        if (isNullOrEmpty(delimitedValues)) {
            return null;
        }
        return ImmutableList.copyOf(Splitter.on(delimiter).split(delimitedValues));
    }

    /**
     * Pads the given collection with distinct negative values up to the given size.
     * If the given collection is larger than the size, it is returned unchanged.
     *
     * @param collection collection to pad
     * @param size       final size of the collection to return
     * @return the given collection padded to the given size
     */
    public static Collection<Integer> padIntToSize(final Collection<Integer> collection, final int size) {
        return padToSize(collection, size, UNMATCHABLE_INT_DISTINCT_IDS);
    }

    public static Collection<Long> padLongToSize(final Collection<Long> collection, final int size) {
        return padToSize(collection, size, UNMATCHABLE_LONG_DISTINCT_IDS);
    }

    /**
     * Test if a column name exists within the given result set.
     *
     * @param row           A result set
     * @param columnName    A column name
     * @return True if the column name exists in the given result set
     * @throws SQLException If there is a problem accessing the result set
     */
    public static boolean hasColumn(final ResultSet row, final String columnName) throws SQLException {
        final ResultSetMetaData metaData = row.getMetaData();
        for (int i = 1; i <= metaData.getColumnCount(); i++) {
            final String name = metaData.getColumnName(i);
            if (columnName.equals(name)) return true;
        }
        return false;
    }

    public static <T> Collection<T> padToSize(final Collection<T> collection, final int size, final List<T> padding) {
        if (collection != null && collection.size() >= size) return collection;

        if (size > padding.size()) throw new IllegalArgumentException();

        final List<T> padded = newArrayList(padding.subList(0, size));

        if (collection == null) return padded;

        final Iterator<T> iterator = collection.iterator();
        for (int i = 0; i < collection.size(); ++i) {
            padded.set(i, iterator.next());
        }
        return padded;
    }
}
