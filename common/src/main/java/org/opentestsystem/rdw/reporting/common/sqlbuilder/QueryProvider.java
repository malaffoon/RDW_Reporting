package org.opentestsystem.rdw.reporting.common.sqlbuilder;

import com.healthmarketscience.sqlbuilder.CustomCondition;
import com.healthmarketscience.sqlbuilder.CustomSql;
import com.healthmarketscience.sqlbuilder.SelectQuery;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import static com.google.common.base.Preconditions.checkArgument;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.FROM;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.GROUP_BY;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.JOIN;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.SELECT;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.WHERE;

/**
 * This class is responsible for constructing sql queries from {@link SqlTemplate} defined by {@link SqlBuilderConfig}
 */
@Component
public class QueryProvider {

    private final SqlBuilderConfig sqlBuilderConfig;

    /**
     * Constructor
     *
     * @param sqlBuilderConfig the {@link SqlBuilderConfig}
     */
    @Autowired
    public QueryProvider(final SqlBuilderConfig sqlBuilderConfig) {
        this.sqlBuilderConfig = sqlBuilderConfig;
    }

    /**
     * Returns a {@link SelectQuery} constructed by scanning the {@link SqlTemplate} and applying its{@link SqlTemplate#addons}
     *
     * @param templateName the {@link SqlTemplate}'s name
     * @param addons       the {@link SqlTemplate#addons}'s names
     * @return constructed {@link SelectQuery}
     */
    public SelectQuery newQuery(final String templateName, final Iterable<String> addons) {
        checkArgument(sqlBuilderConfig.getTemplates() != null && sqlBuilderConfig.getTemplates().containsKey(templateName), "unknown sql builder template name " + templateName);

        final SqlTemplate template = sqlBuilderConfig.getTemplates().get(templateName);
        checkArgument(template.getClauses() != null && template.getClauses().containsKey(FROM), "missing from clause for template " + templateName);

        final SelectQuery query = new SelectQuery().addCustomFromTable(template.clauses.get(FROM));
        addClauses(template, query);

        for (final String addon : addons) {
            checkArgument(template.getAddons() != null && template.getAddons().containsKey(addon), "missing sqlbuilder addon template " + templateName);
            addClauses(template.getAddons().get(addon), query);
        }

        return query;
    }

    /**
     * Returns a SQL string constructed by scanning the {@link SqlTemplate} and applying its{@link SqlTemplate#addons}
     *
     * @param templateName the {@link SqlTemplate}'s name
     * @param addons       the {@link SqlTemplate#addons}'s names
     * @return constructed SQL string
     */
    public String newQueryAsString(final String templateName, final Iterable<String> addons) {
        return newQuery(templateName, addons).toString();
    }

    private void addClauses(final SqlTemplate template, final SelectQuery query) {
        // FROM clause is applicable to the main template only and is handled separately
        final SqlClause[] clauses = {SELECT, JOIN, WHERE, GROUP_BY};

        for (final SqlClause clause : clauses) {
            if (template.getClauses().containsKey(clause)) {
                addClause(query, clause, template.getClauses().get(clause));
            }
        }
    }

    private void addClause(final SelectQuery query, final SqlClause clause, final String clauseSql) {
        final String customSql = " " + clauseSql;
        switch (clause) {
            case SELECT:
                query.addCustomColumns(new CustomSql(customSql));
                break;
            case JOIN:
                query.addCustomJoin(customSql);
                break;
            case WHERE:
                query.addCondition(new CustomCondition(customSql));
                break;
            case GROUP_BY:
                query.addCustomGroupings(customSql);
                break;
            default:
                throw new IllegalArgumentException("unsupported request for the given clause " + clause);
        }
    }
}
