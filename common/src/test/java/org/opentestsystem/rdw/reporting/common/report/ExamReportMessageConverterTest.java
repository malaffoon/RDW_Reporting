package org.opentestsystem.rdw.reporting.common.report;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReport;
import org.opentestsystem.rdw.reporting.common.report.processor.ExamReportPdfProcessor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.mock.http.MockHttpOutputMessage;

import java.util.Locale;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class ExamReportMessageConverterTest {

    private ExamReportPdfMessageConverter converter;
    private ExamReportPdfProcessor processor;

    @Before
    public void before() {
        processor = mock(ExamReportPdfProcessor.class);
        converter = new ExamReportPdfMessageConverter(processor);
    }

    @Test
    public void canWriteShouldBeTrueForPDFMediaType() throws Exception {
        assertThat(converter.canWrite(ExamReportMessage.class, MediaType.APPLICATION_PDF)).isTrue();
    }

    @Test
    public void canWriteShouldBeFalseForMediaTypesOtherThanPDF() throws Exception {
        assertThat(converter.canWrite(ExamReportMessage.class, MediaType.APPLICATION_JSON)).isFalse();
    }

    @Test
    public void supportsShouldAcceptPdfExamReportResponses() throws Exception {
        assertThat(converter.supports(ExamReportMessage.class)).isTrue();
        assertThat(converter.supports(String.class)).isFalse();
    }

    @Test(expected = UnsupportedOperationException.class)
    public void readInternalShouldThrowException() throws Exception {
        converter.readInternal(null, null);
    }

    @Test
    public void writeInternalShouldInvokeProcessorAndWriteContentDispositionHeader() throws Exception {
        final byte[] expected = {0x17, 0x34};

        final AbstractExamReport report = IcaReport.builder()
                .student(Student.builder()
                        .firstName("firstName")
                        .lastName("lastName")
                        .build()
                )
                .build();

        final AbstractExamReportRequest<PrintOptions> request = new AbstractExamReportRequest<PrintOptions>() {
            @Override
            public ExamReportAssessmentType getAssessmentType() {
                return ExamReportAssessmentType.ICA;
            }

            @Override
            public int getSchoolYear() {
                return 2017;
            }

            @Override
            public Locale getLanguage() {
                return Locale.ENGLISH;
            }

            @Override
            public Subject getSubject() { return Subject.MATH; }
        };

        final String expectedContentDisposition = "attachment; filename=lastName_firstName_MATH_ICA_2017.pdf";
        final ExamReportMessage model = new ExamReportMessage(report, request);
        final MockHttpOutputMessage message = new MockHttpOutputMessage();
        when(processor.process(report, request)).thenReturn(expected);

        converter.writeInternal(model, message);

        assertThat(message.getBodyAsBytes()).isEqualTo(expected);
        assertThat(message.getHeaders().getFirst(HttpHeaders.CONTENT_DISPOSITION)).isEqualTo(expectedContentDisposition);
    }

}