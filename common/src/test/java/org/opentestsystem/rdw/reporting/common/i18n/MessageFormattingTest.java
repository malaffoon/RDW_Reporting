package org.opentestsystem.rdw.reporting.common.i18n;

import org.junit.BeforeClass;
import org.junit.Test;
import org.springframework.context.MessageSource;
import org.springframework.context.support.ResourceBundleMessageSource;

import java.io.IOException;
import java.util.Locale;
import java.util.Properties;
import java.util.function.BiConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.IntStream;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * This test is to ensure the content put in the messages.properties is formatted correctly for the expected display
 */
public class MessageFormattingTest {

    /**
     * The resource bundle to test
     */
    private static final String resourceBundleBasename = "messages";

    /**
     * The locales the bundle currently supports
     */
    private static final Locale[] supportedLocales = new Locale[]{null, new Locale("es"), new Locale("vi")};

    /**
     * Finds and extracts formatted message placeholders
     */
    private static final Pattern formattedMessagePattern = Pattern.compile("\\{(\\d+)\\}");

    /**
     * Finds anchor tags in messages
     */
    private static final Pattern anchorPattern = Pattern.compile("<a .*</a>");

    /**
     * The message source to test
     */
    private static MessageSource source;


    @BeforeClass
    public static void beforeClass() {
        final ResourceBundleMessageSource baseMessages = new ResourceBundleMessageSource();
        baseMessages.setBasenames(resourceBundleBasename);
        source = baseMessages;
    }

    /**
     * In property files, formatted messages require single apostrophes to be escaped by a leading single apostrophe.
     * Unformatted messages do not require escaping single apostrophes.
     * This test asserts after processing of messages, there is no instance of consecutive apostrophes in the message.
     *
     * @throws Exception
     */
    @Test
    public void itShouldNotShowConsecutiveApostrophes() throws Exception {
        eachMessage((code, message) -> {
            assertThat(message).doesNotContain("{0}");
            assertThat(message).as("Message code: %s", code).doesNotContain("''");
        });
    }

    /**
     * This test makes sure all HTML anchor tags open in new tabs with target="_blank"
     *
     * @throws Exception
     */
    @Test
    public void allLinksShouldOpenInNewTabs() throws Exception {
        eachMessage((code, message) -> {
            final Matcher matcher = anchorPattern.matcher(message);
            while (matcher.find()) {
                final String anchor = matcher.group(0);
                assertThat(anchor).contains(" target=\"_blank\" ");
            }
        });
    }

    /**
     * Calls callback on each message of each message source property file
     *
     * @param callback the method to call with each message code and message
     * @throws Exception
     */
    private void eachMessage(BiConsumer<String, String> callback) throws Exception {
        for (final Locale locale : supportedLocales) {
            for (final Object key : getProperties(locale).keySet()) {
                final String code = (String) key;
                final String message = getMessage(source, code, locale);
                callback.accept(code, message);
            }
        }
    }

    /**
     * @param locale the locale of the message source property file
     * @return the resource bundle property file for the given locale
     * @throws IOException
     */
    private Properties getProperties(final Locale locale) throws IOException {
        final Properties properties = new Properties();
        properties.load(getClass().getClassLoader().getResourceAsStream(getPropertyFilePath(resourceBundleBasename, locale)));
        return properties;
    }

    /**
     * @param locale the locale of the message source property file
     * @return path to the resource bundle property file for the given locale
     */
    private String getPropertyFilePath(final String basename, final Locale locale) {
        if (locale == null) {
            return basename + ".properties";
        }
        return String.format("%s_%s.properties", basename, locale.getLanguage());
    }

    /**
     * This method returns {@link MessageSource#getMessage(String, Object[], Locale)} for the given code and locale.
     * If the message is found to contain {N} parameter placeholders the method resolves these placeholders with PARAM_N format.
     *
     * @param source the message source to use
     * @param code   the message code
     * @param locale the locale to use
     * @return
     */
    private String getMessage(final MessageSource source, final String code, final Locale locale) {

        final String unformattedMessage = source.getMessage(code, null, locale);

        final Matcher matcher = formattedMessagePattern.matcher(unformattedMessage);
        int maximumIndex = -1;
        while (matcher.find()) {
            final int index = Integer.parseInt(matcher.group(1));
            if (index > maximumIndex) {
                maximumIndex = index;
            }
        }

        return maximumIndex >= 0
                ? source.getMessage(code, IntStream.range(0, maximumIndex + 1).mapToObj(i -> "PARAM_" + i).toArray(String[]::new), locale)
                : unformattedMessage;
    }

}
