package org.opentestsystem.rdw.admin.multitenant.configprops;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Sets;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.task.ArtClientPropertiesRoot;
import org.opentestsystem.rdw.multitenant.task.ImportServiceClientPropertiesRoot;
import org.opentestsystem.rdw.multitenant.task.SendReconciliationReportPropertiesRoot;
import org.opentestsystem.rdw.multitenant.validation.ExamProcessorValidationPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.admin.multitenant.configprops.RDWServices.RDW_INGEST_MIGRATE_OLAP;
import static org.opentestsystem.rdw.admin.multitenant.configprops.RDWServices.RDW_INGEST_MIGRATE_REPORTING;
import static org.opentestsystem.rdw.admin.multitenant.configprops.RDWServices.RDW_REPORTING_ADMIN_SERVICE;
import static org.opentestsystem.rdw.admin.multitenant.configprops.RDWServices.RDW_REPORTING_REPORT_PROCESSOR;
import static org.opentestsystem.rdw.admin.multitenant.configprops.RDWServices.RDW_REPORTING_SERVICE;

public class DefaultConfigpropsService implements ConfigpropsService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultConfigpropsService.class);

    private final ConfigpropsConsolidationService configpropsConsolidationService;
    private final ObjectMapper mapper;

    private final String ArchiveConfigTypeKey = "archive";
    private final String ReportingConfigTypeKey = "reporting";
    private final String AggregateReportingConfigTypeKey = "aggregateReporting";
    private final String TenantPropertiesConfigTypeKey = "tenantProperties";
    private final String ValidationConfigTypeKey = "validation";
    private final String TaskUpdateOrganizationsArtClientConfigTypeKey = "taskUpdateOrganizationsArtClient";
    private final String TaskUpdateOrganizationsImportServiceClientConfigTypeKey = "taskUpdateOrganizationsImportServiceClient";
    private final String TaskSendReconciliationReportConfigTypeKey = "taskSendReconciliationReport";
    private final String DatasourcesMigrateRwConfigTypeKey = "datasources.migrate_rw";
    private final String DatasourcesOlapRoConfigTypeKey = "datasources.olap_ro";
    private final String DatasourcesOlapRwConfigTypeKey = "datasources.olap_rw";
    private final String DatasourcesReportingRoConfigTypeKey = "datasources.reporting_ro";
    private final String DatasourcesReportingRwConfigTypeKey = "datasources.reporting_rw";
    private final String DatasourcesWarehouseRwConfigTypeKey = "datasources.warehouse_rw";

    public DefaultConfigpropsService(final ConfigpropsConsolidationService configpropsConsolidationService,
                                     final ObjectMapper mapper) {

        this.configpropsConsolidationService = configpropsConsolidationService;
        this.mapper = mapper;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
    }

    @Override
    public Optional<ReportingSystemSettings> defaultReportingSystemProperties() {
        Map<String, ReportingSystemSettings> reportingSystemSettings =
                serviceConfigurationMap(ReportingConfigTypeKey, ReportingSystemSettings.class);

        HashSet<ReportingSystemSettings> set = Sets.newHashSet(reportingSystemSettings.values());
        if (set.size() > 1) {
            if (reportingSystemSettings.containsKey(RDWServices.RDW_REPORTING_WEBAPP.getName())
                    && reportingSystemSettings.containsKey(RDWServices.RDW_REPORTING_SERVICE.getName())) {
                ReportingSystemSettings webappSettings = reportingSystemSettings.get(RDWServices.RDW_REPORTING_WEBAPP.getName());
                ReportingSystemSettings reportingServiceSettings = reportingSystemSettings.get(RDWServices.RDW_REPORTING_SERVICE.getName());
                //prefer webapp except for school year, state, and and student fields
                webappSettings.setSchoolYear(reportingServiceSettings.getSchoolYear());
                webappSettings.setState(reportingServiceSettings.getState());
                webappSettings.setStudentFields(reportingServiceSettings.getStudentFields());
                return Optional.of(webappSettings);
            }
        }
        // fall through in the case of new configurations publishing out,
        // the configuration may not yet be the preferred one so
        // fall back to first available
        logger.debug("More than one {} resolved count[{}] {}", ReportingConfigTypeKey, set.size(), set);
        return set.stream().findFirst();
    }

    @Override
    public Optional<ReportingSystemPropertiesImpl> reportingSystemProperties(final String tenantKey) {
        return defaultReportingSystemProperties()
                .map(reportingSystemSettings -> reportingSystemSettings.getTenants()
                        .get(tenantKey));
    }

    @Override
    public Optional<ArchivePropertiesRoot> defaultArchiveProperties() {
        return condenseConfigurations(
                serviceConfigurationMap(ArchiveConfigTypeKey, ArchivePropertiesRoot.class),
                ArchiveConfigTypeKey);
    }

    @Override
    public Optional<ArchivePropertiesTenant> archiveProperties(final String tenantKey) {
        return defaultArchiveProperties()
                .map(reportingSystemSettings -> reportingSystemSettings.getTenants()
                        .get(tenantKey));
    }

    @Override
    public Optional<AggregateReportingPropertiesRoot> defaultAggregateReportingProperties() {
        return condenseConfigurations(
                serviceConfigurationMap(AggregateReportingConfigTypeKey, AggregateReportingPropertiesRoot.class),
                AggregateReportingConfigTypeKey);
    }

    @Override
    public Optional<AggregateReportingPropertiesTenant> aggregateReportingProperties(final String tenantKey) {
        return defaultAggregateReportingProperties()
                .map(aggregateReportingPropertiesRoot -> aggregateReportingPropertiesRoot.getTenants().get(tenantKey));
    }

    @Override
    public Optional<TenantProperties> tenantProperties() {
        return condenseConfigurations(
                serviceConfigurationMap(TenantPropertiesConfigTypeKey, TenantProperties.class),
                TenantPropertiesConfigTypeKey);
    }

    @Override
    public Map<String, DataSourceElementsProperties> defaultDataSourceElements() {
        final String configTypeKeyPrefix = "datasources.";
        return configuredDataSourceKeys()
                .stream()
                .map(key -> ImmutablePair.of(StringUtils.removeStart(key, configTypeKeyPrefix),
                        defaultDataSourceElementsByConfigType(key)))
                .filter(pair -> pair.getRight().isPresent())
                .collect(Collectors.toMap(ImmutablePair::getLeft, pair -> pair.getRight().get()));
    }

    @Override
    public Map<String, DataSourceElementsTenant> dataSourceElements(final String tenantKey) {
        return defaultDataSourceElements()
                .entrySet()
                .stream()
                .map(entry -> ImmutablePair.of(entry.getKey(), entry.getValue().getTenants().get(tenantKey)))
                .filter(pair -> pair.getRight() != null)
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    @Override
    public Optional<ExamProcessorValidationPropertiesRoot> defaultValidation() {
        return condenseConfigurations(
                serviceConfigurationMap(ValidationConfigTypeKey, ExamProcessorValidationPropertiesRoot.class),
                ValidationConfigTypeKey);
    }

    @Override
    public Optional<ArtClientPropertiesRoot> defaultArtClient() {
        return condenseConfigurations(
                serviceConfigurationMap(TaskUpdateOrganizationsArtClientConfigTypeKey, ArtClientPropertiesRoot.class),
                TaskUpdateOrganizationsArtClientConfigTypeKey);
    }

    @Override
    public Optional<ImportServiceClientPropertiesRoot> defaultImportServiceClient() {
        return condenseConfigurations(
                serviceConfigurationMap(TaskUpdateOrganizationsImportServiceClientConfigTypeKey, ImportServiceClientPropertiesRoot.class),
                TaskUpdateOrganizationsImportServiceClientConfigTypeKey);
    }

    @Override
    public Optional<SendReconciliationReportPropertiesRoot> defaultSendReconciliationReport() {
        return condenseConfigurations(
                serviceConfigurationMap(TaskSendReconciliationReportConfigTypeKey, SendReconciliationReportPropertiesRoot.class),
                TaskSendReconciliationReportConfigTypeKey);
    }

    /**
     * Default configuration for a datasource
     *
     * @param configTypeKey specific configuration
     * @return datasource elements
     */
    private Optional<DataSourceElementsProperties> defaultDataSourceElementsByConfigType(final String configTypeKey) {
        return condenseConfigurations(
                serviceConfigurationMap(configTypeKey, DataSourceElementsProperties.class),
                configTypeKey);
    }

    /**
     * All keys that are prefixed by "datasource."
     *
     * @return Set of configTypeKey
     */
    private Set<String> configuredDataSourceKeys() {
        final String configTypeKeyPrefix = "datasources.";
        return configpropsConsolidationService
                .extractServicePrefixProperties()
                .values()
                .stream()
                .flatMap(stringJsonNodeMap -> stringJsonNodeMap.keySet().stream())
                .filter(configTypeKey -> configTypeKey.startsWith(configTypeKeyPrefix))
                .collect(Collectors.toSet());
    }

    /**
     * Convert a map of serviceName to configuration into a single optional configuration
     * warns if there are duplicate configurations
     *
     * @param configurations serviceName to configuration map
     * @param configTypeKey  The type of configuration to extract ("reporting", "archive", "aggregate-reporting", etc)
     * @param <T>            Type
     * @return a single optional configuration
     */
    private <T> Optional<T> condenseConfigurations(final Map<String, T> configurations, final String configTypeKey) {
        HashSet<T> configurationSet = Sets.newHashSet(configurations.values());
        //rules for those with more than one configuration expected
        if (configurationSet.size() > 1) {
            switch (configTypeKey) {
                case ArchiveConfigTypeKey:
                    if (configurations.containsKey(RDW_REPORTING_REPORT_PROCESSOR.getName())) {
                        return Optional.of(configurations.get(RDW_REPORTING_REPORT_PROCESSOR.getName()));
                    }
                    break;
                case DatasourcesReportingRoConfigTypeKey:
                    if (configurations.containsKey(RDW_REPORTING_SERVICE.getName())) {
                        return Optional.of(configurations.get(RDW_REPORTING_SERVICE.getName()));
                    }
                    break;
                case DatasourcesReportingRwConfigTypeKey:
                    if (configurations.containsKey(RDW_INGEST_MIGRATE_REPORTING.getName())) {
                        return Optional.of(configurations.get(RDW_INGEST_MIGRATE_REPORTING.getName()));
                    }
                    break;
                case DatasourcesWarehouseRwConfigTypeKey:
                    if (configurations.containsKey(RDW_INGEST_MIGRATE_OLAP.getName())) {
                        return Optional.of(configurations.get(RDW_INGEST_MIGRATE_OLAP.getName()));
                    }
                    break;
                case TenantPropertiesConfigTypeKey:
                    if (configurations.containsKey(RDW_REPORTING_ADMIN_SERVICE.getName())) {
                        return Optional.of(configurations.get(RDW_REPORTING_ADMIN_SERVICE.getName()));
                    }
                    break;
            }
            logger.debug("More than one {} resolved count[{}] {}", configTypeKey, configurationSet.size(), configurationSet);
        }
        // fall through in the case of new configurations publishing out,
        // the configuration may not yet be the preferred one so
        // fall back to first available
        return configurationSet.stream().findFirst();
    }

    /**
     * Get a Map of service names to matching parsed objects
     *
     * @param configTypeKey The type of configuration to extract ("reporting", "archive", "aggregate-reporting", etc)
     * @param valueType     Type to parse to
     * @param <T>           Type
     * @return Map of service names to parsed objects
     */
    private <T> Map<String, T> serviceConfigurationMap(final String configTypeKey, final Class<T> valueType) {
        return findJsonByKey(configTypeKey)
                .entrySet()
                .stream()
                .map(entry -> ImmutablePair.of(entry.getKey(), treeToValue(entry.getValue(), valueType)))
                .filter(pair -> pair.getRight().isPresent())
                .collect(Collectors.toMap(ImmutablePair::getLeft, pair -> pair.getRight().get()));
    }

    /**
     * Get a Map of service names to matching JsonNode configurations for a particular configuration type.
     *
     * @param configTypeKey The type of configuration to extract ("reporting", "archive", "aggregate-reporting", etc)
     * @return Map of service names to {@link JsonNode} configuration
     */
    @VisibleForTesting
    Map<String, JsonNode> findJsonByKey(final String configTypeKey) {
        return configpropsConsolidationService
                .extractServicePrefixProperties()
                .entrySet()
                .stream()
                .map(m -> ImmutablePair.of(m.getKey(), m.getValue().get(configTypeKey)))
                .filter(pair -> pair.getRight() != null)
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    /**
     * Parse a {@link JsonNode} to a class, will not throw an exception (logs warning)
     *
     * @param n         Node to parse
     * @param valueType Type to parse to
     * @param <T>       Type
     * @return The parsed type or Optional empty
     */
    @VisibleForTesting
    <T> Optional<T> treeToValue(final TreeNode n, final Class<T> valueType) {
        try {
            return Optional.ofNullable(mapper.treeToValue(n, valueType));
        } catch (JsonProcessingException e) {
            logger.warn("Error parsing JSON", e);
            return Optional.empty();
        }
    }
}
