package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.lang.StringUtils;
import org.codehaus.groovy.control.CompilationFailedException;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.admin.model.Pipeline;
import org.opentestsystem.rdw.admin.model.PipelineScript;
import org.opentestsystem.rdw.admin.model.PipelineTest;
import org.opentestsystem.rdw.admin.model.PipelineTestResult;
import org.opentestsystem.rdw.admin.model.PipelineTestRun;
import org.opentestsystem.rdw.admin.repository.PipelineRepository;
import org.opentestsystem.rdw.admin.repository.PipelineScriptRepository;
import org.opentestsystem.rdw.admin.repository.PipelineTestRepository;
import org.opentestsystem.rdw.admin.service.PipelineOutputComparisonService;
import org.opentestsystem.rdw.admin.service.PipelineService;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScriptDefinition;
import org.opentestsystem.rdw.script.PipelineScriptType;
import org.opentestsystem.rdw.script.ScriptError;
import org.opentestsystem.rdw.script.ScriptRuntimeException;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.admin.support.XmlStrings.hasHeader;
import static org.opentestsystem.rdw.admin.support.XmlStrings.removeHeader;
import static org.opentestsystem.rdw.script.ScriptCompilers.toScriptCompiler;
import static org.opentestsystem.rdw.script.ScriptErrors.toScriptErrors;

/**
 * Default implementation of the pipeline service.
 */
@Service
class DefaultPipelineService implements PipelineService {

    private final PipelineRepository repository;
    private final PipelineScriptRepository scriptRepository;
    private final PipelineTestRepository testRepository;
    private final PublishedPipelineRepository publishedPipelineRepository;
    private final PipelineFactory pipelineFactory;
    private final PipelineOutputComparisonService pipelineOutputComparisonService;
    private final ScriptSource scriptSource;

    DefaultPipelineService(
            final PipelineRepository repository,
            final PipelineScriptRepository scriptRepository,
            final PipelineTestRepository testRepository,
            final PublishedPipelineRepository publishedPipelineRepository,
            final PipelineFactory pipelineFactory,
            final PipelineOutputComparisonService pipelineOutputComparisonService,
            final ScriptSource scriptSource) {
        this.repository = repository;
        this.scriptRepository = scriptRepository;
        this.testRepository = testRepository;
        this.publishedPipelineRepository = publishedPipelineRepository;
        this.pipelineFactory = pipelineFactory;
        this.pipelineOutputComparisonService = pipelineOutputComparisonService;
        this.scriptSource = scriptSource;
    }

    @Override
    public List<Pipeline> getPipelines() {
        return repository.findAll();
    }

    @Override
    public Pipeline getPipeline(final int id) {
        return repository.findById(id);
    }

    @Override
    public Pipeline updatePipeline(final Pipeline pipeline) {
        return repository.update(pipeline);
    }

    @Override
    public List<PipelineDefinition> getPublishedPipelines(final String pipelineCode, final String version) {
        return getPipelineDefinitionsInternal(pipelineCode, version).stream()
                .map(this::removeSystemScripts)
                .collect(toList());
    }

    @Override
    public List<PipelineScript> getScripts(final int pipelineId) {
        return scriptRepository.findAllByPipeline(pipelineId);
    }

    @Override
    public List<PipelineTest> getTests(final int pipelineId) {
        return testRepository.findAllByPipeline(pipelineId);
    }

    @Override
    public List<ScriptError> compile(final int pipelineId, final String scriptBody) {
        final Pipeline pipeline = repository.findById(pipelineId);
        try {
            toScriptCompiler(
                    scriptSource.getScript(PipelineScriptType.Base, pipeline.getCode()).get().getBody()
            ).compile(scriptBody);
        } catch (final CompilationFailedException exception) {
            return toScriptErrors(exception);
        }
        return emptyList();
    }

    @Override
    public List<PipelineTestRun> test(final int pipelineId) {
        return test(pipelineId, null);
    }

    @Override
    public List<PipelineTestRun> test(final int pipelineId, final Collection<Integer> testIds) {
        final Pipeline pipeline = repository.findById(pipelineId);
        final List<PipelineScript> scripts = scriptRepository.findAllByPipeline(pipelineId);
        final List<PipelineTest> tests = testRepository.findAllByPipeline(pipelineId);
        return tests.stream()
                .filter(test ->
                        testIds == null || testIds.contains(test.getId())
                )
                .map(test -> run(test, scripts, pipeline))
                .collect(toList());
    }

    @Override
    public PipelineDefinition publish(final int pipelineId, final String username) {

        final Pipeline pipeline = repository.findById(pipelineId);

        // create record of published pipeline
        final PipelineDefinition published = publishedPipelineRepository.create(
                PipelineDefinition.builder()
                        .pipelineCode(pipeline.getCode())
                        .publishedBy(username)
                        .scripts(
                                scriptRepository.findAllByPipeline(pipelineId).stream()
                                        .map(script ->
                                                PipelineScriptDefinition.builder()
                                                        .type(PipelineScriptType.User)
                                                        .body(script.getBody())
                                                        .build()
                                        )
                                        .collect(toList())
                        )
                        .build()
        );

        // set active version to newly published version
        updatePipeline(
                pipeline.copy()
                        .activeVersion(published.getVersion())
                        .build()
        );

        return published;
    }

    /**
     * Runs a specific pipeline test
     *
     * @param test     The test to run
     * @param scripts  The scripts to execute
     * @param pipeline The pipeline the test is run for
     * @return The test run results
     */
    private PipelineTestRun run(final PipelineTest test, final List<PipelineScript> scripts, final Pipeline pipeline) {
        final PipelineTestRun.Builder run = PipelineTestRun.builder()
                .test(test);

        final org.opentestsystem.rdw.script.Pipeline developmentPipeline = pipelineFactory
                .getDevelopmentPipeline(
                        pipeline.getCode(),
                        pipeline.getActiveVersion(),
                        scripts.get(0).getBody()
                );

        try {
            final String output = developmentPipeline.run(test.getInput()).asString();

            // if the expected does not have a header remove the header from the output to not add confusion to the diff view
            final String normalizedOutput = hasHeader(test.getOutput())
                    ? output
                    : removeHeader(output);

            try {
                // check if expected output matches actual output
                if (!pipelineOutputComparisonService.equals(test.getOutput(), normalizedOutput, pipeline.getInputType())) {
                    return run.result(PipelineTestResult.failedWithOutput(normalizedOutput))
                            .build();
                }
            } catch (final RuntimeException exception) {
                return run.result(PipelineTestResult.failedWithScriptErrors(newArrayList(
                        new ScriptError(String.format(
                                "Invalid script output. Expected valid %s but got \"%s\"",
                                pipeline.getInputType(),
                                StringUtils.abbreviateMiddle(normalizedOutput, "...", 30)
                        ), 1)
                ))).build();
            }

            // TODO process for schema errors when the interface is available

            return run.result(PipelineTestResult.passed())
                    .build();

        } catch (final ScriptRuntimeException exception) {
            final ScriptError error = new ScriptError(
                    exception.getMessage(),
                    exception.getLineNumber()
            );
            // script execution failed
            return run.result(PipelineTestResult.failedWithScriptErrors(newArrayList(
                    error
            )))
                    .build();
        }
    }

    /**
     * Gets the published pipelines filtering by pipeline code and version
     *
     * @param pipelineCode The pipeline code
     * @param version      The published pipeline version
     * @return the published pipelines filtering by pipeline code and version
     */
    private List<PipelineDefinition> getPipelineDefinitionsInternal(final String pipelineCode, final String version) {
        if (version == null) {
            return publishedPipelineRepository.findAllByCode(pipelineCode);
        }
        final PipelineDefinition pipeline = publishedPipelineRepository.findByCodeAndVersion(pipelineCode, version);
        if (pipeline != null) {
            return newArrayList(pipeline);
        }
        return emptyList();
    }

    /**
     * Removes system scripts from published pipelines because the admin UI is not concerned with them
     *
     * @return The provided published pipeline without system scripts
     */
    private PipelineDefinition removeSystemScripts(final PipelineDefinition PipelineDefinition) {
        if (PipelineDefinition == null) {
            return null;
        }
        return PipelineDefinition.copy()
                .scripts(
                        PipelineDefinition.getScripts().stream()
                                .filter(script -> script.getType() == PipelineScriptType.User)
                                .collect(Collectors.toList())
                ).build();
    }

}
