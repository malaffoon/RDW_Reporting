package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.lang3.StringUtils;
import org.codehaus.groovy.control.CompilationFailedException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.admin.model.Pipeline;
import org.opentestsystem.rdw.admin.model.PipelineScript;
import org.opentestsystem.rdw.admin.model.PipelineTest;
import org.opentestsystem.rdw.admin.model.PipelineTestResult;
import org.opentestsystem.rdw.admin.model.PipelineTestRun;
import org.opentestsystem.rdw.admin.repository.PipelineRepository;
import org.opentestsystem.rdw.admin.repository.PipelineScriptRepository;
import org.opentestsystem.rdw.admin.repository.PipelineTestRepository;
import org.opentestsystem.rdw.admin.service.PipelineOutputComparisonService;
import org.opentestsystem.rdw.admin.service.PipelineService;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineResults;
import org.opentestsystem.rdw.script.PipelineScriptDefinition;
import org.opentestsystem.rdw.script.PipelineScriptType;
import org.opentestsystem.rdw.script.ScriptError;
import org.opentestsystem.rdw.script.ScriptRuntimeException;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.script.ScriptCompilers.toScriptCompiler;
import static org.opentestsystem.rdw.script.ScriptErrors.toScriptErrors;

/**
 * Default implementation of the pipeline service.
 */
@Service
class DefaultPipelineService implements PipelineService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultPipelineService.class);

    private final PipelineRepository repository;
    private final PipelineScriptRepository scriptRepository;
    private final PipelineTestRepository testRepository;
    private final PublishedPipelineRepository publishedPipelineRepository;
    private final PipelineFactory pipelineFactory;
    private final PipelineOutputComparisonService pipelineOutputComparisonService;
    private final ScriptSource scriptSource;

    DefaultPipelineService(
            final PipelineRepository repository,
            final PipelineScriptRepository scriptRepository,
            final PipelineTestRepository testRepository,
            final PublishedPipelineRepository publishedPipelineRepository,
            final PipelineFactory pipelineFactory,
            final PipelineOutputComparisonService pipelineOutputComparisonService,
            final ScriptSource scriptSource) {
        this.repository = repository;
        this.scriptRepository = scriptRepository;
        this.testRepository = testRepository;
        this.publishedPipelineRepository = publishedPipelineRepository;
        this.pipelineFactory = pipelineFactory;
        this.pipelineOutputComparisonService = pipelineOutputComparisonService;
        this.scriptSource = scriptSource;
    }

    @Override
    public List<Pipeline> getPipelines() {
        return repository.findAll();
    }

    @Override
    public Pipeline getPipeline(final int id) {
        return repository.findById(id);
    }

    @Override
    public Pipeline updatePipeline(final Pipeline pipeline) {
        return repository.update(pipeline);
    }

    @Override
    public List<PipelineDefinition> getPublishedPipelines(final String pipelineCode, final String version) {
        return getPipelineDefinitionsInternal(pipelineCode, version).stream()
                .map(this::removeSystemScripts)
                .collect(toList());
    }

    @Override
    public List<PipelineScript> getScripts(final int pipelineId) {
        return scriptRepository.findAllByPipeline(pipelineId);
    }

    @Override
    public List<PipelineTest> getTests(final int pipelineId) {
        return testRepository.findAllByPipeline(pipelineId);
    }

    @Override
    public List<ScriptError> compile(final int pipelineId, final String scriptBody) {
        final Pipeline pipeline = repository.findById(pipelineId);
        try {
            toScriptCompiler(
                    scriptSource.getScript(PipelineScriptType.Base, pipeline.getCode())
                            .map(PipelineScriptDefinition::getBody)
                            .orElseThrow(() -> new IllegalStateException(String.format(
                                    "The \"%s\" pipeline has no base script configured",
                                    pipeline.getCode()
                            )))
            ).compile(scriptBody);
        } catch (final CompilationFailedException exception) {
            return toScriptErrors(exception);
        } catch (final Exception exception) {
            return singletonList(new ScriptError(
                    "Compilation failed. Please see logs for details"
            ));
        }
        return emptyList();
    }

    @Override
    public String getNormalizedOutput(final String output, final Integer pipelineId) {
        final Pipeline pipeline = repository.findById(pipelineId);
        try {
            final String scriptBody =
                    scriptSource.getScript(PipelineScriptType.Normalize, pipeline.getCode())
                            .map(PipelineScriptDefinition::getBody)
                            .orElseThrow(() -> new NoSuchElementException(String.format(
                                    "The \"%s\" pipeline has no normalize script configured",
                                    pipeline.getCode()
                            )));
            toScriptCompiler(
                    scriptSource.getScript(PipelineScriptType.Base, pipeline.getCode())
                            .map(PipelineScriptDefinition::getBody)
                            .orElseThrow(() -> new IllegalStateException(String.format(
                                    "The \"%s\" pipeline has no base script configured",
                                    pipeline.getCode()
                            )))
            ).compile(scriptBody);

            final org.opentestsystem.rdw.script.Pipeline developmentPipeline = pipelineFactory
                    .getDevelopmentPipeline(
                            "n/a",
                            "n/a",
                            scriptBody
                    );

            final PipelineResults results = developmentPipeline.run(output);
            return results.asString();
        } catch (final NoSuchElementException e) {
            logger.debug("Cannot normalize expected output: " + e.getMessage());
        } catch (final Exception exception) {
            logger.warn("Error normalizing expected output" + exception.getMessage());
        }

        // If no normalizing script found, or it failed to run, then return the expected output unchanged.
        return output;
    }

    @Override
    public List<PipelineTestRun> test(final int pipelineId) {
        return test(pipelineId, null);
    }

    @Override
    public List<PipelineTestRun> test(final int pipelineId, final Collection<Integer> testIds) {
        final Pipeline pipeline = repository.findById(pipelineId);
        final List<PipelineScript> scripts = scriptRepository.findAllByPipeline(pipelineId);
        final List<PipelineTest> tests = testRepository.findAllByPipeline(pipelineId);
        return tests.stream()
                .filter(test ->
                        testIds == null || testIds.contains(test.getId())
                )
                .map(test -> run(test, scripts, pipeline))
                .collect(toList());
    }

    @Override
    public PipelineDefinition publish(final int pipelineId, final String username) {

        final Pipeline pipeline = repository.findById(pipelineId);

        // create record of published pipeline
        return publishedPipelineRepository.create(
                PipelineDefinition.builder()
                        .pipelineCode(pipeline.getCode())
                        .publishedBy(username)
                        .scripts(
                                scriptRepository.findAllByPipeline(pipelineId).stream()
                                        .map(script ->
                                                PipelineScriptDefinition.builder()
                                                        .type(PipelineScriptType.User)
                                                        .body(script.getBody())
                                                        .build()
                                        )
                                        .collect(toList())
                        )
                        .build()
        );
    }

    /**
     * Runs a specific pipeline test
     *
     * @param test     The test to run
     * @param scripts  The scripts to execute
     * @param pipeline The pipeline the test is run for
     * @return The test run results
     */
    private PipelineTestRun run(final PipelineTest test, final List<PipelineScript> scripts, final Pipeline pipeline) {
        final PipelineTestRun.Builder run = PipelineTestRun.builder()
                .test(test);

        final org.opentestsystem.rdw.script.Pipeline developmentPipeline = pipelineFactory
                .getDevelopmentPipeline(
                        pipeline.getCode(),
                        pipeline.getActiveVersion(),
                        scripts.get(0).getBody()
                );

        try {
            final String output = developmentPipeline.run(test.getInput()).asString();

            try {
                // check if expected output matches actual output
                if (!pipelineOutputComparisonService.equals(test.getOutput(), output, pipeline.getInputType())) {
                    return run.result(PipelineTestResult.failedWithOutput(output))
                            .build();
                }
            } catch (final RuntimeException exception) {
                return run.result(PipelineTestResult.failedWithScriptError(
                        new ScriptError(String.format(
                                "Invalid script output. Expected valid %s but got \"%s\"",
                                pipeline.getInputType(),
                                StringUtils.abbreviateMiddle(output, "...", 30)
                        ), 1)
                )).build();
            }

            // TODO process for schema errors when the interface is available

            return run.result(PipelineTestResult.passed())
                    .build();

        } catch (final ScriptRuntimeException exception) {
            return run.result(PipelineTestResult.failedWithScriptError(
                    new ScriptError(
                            exception.getMessage(),
                            exception.getLineNumber()
                    )
            )).build();
        } catch (final RuntimeException exception) {
            return run.result(PipelineTestResult.failedWithScriptError(
                    new ScriptError(exception.getMessage())
            )).build();
        }
    }

    /**
     * Gets the published pipelines filtering by pipeline code and version
     *
     * @param pipelineCode The pipeline code
     * @param version      The published pipeline version
     * @return the published pipelines filtering by pipeline code and version
     */
    private List<PipelineDefinition> getPipelineDefinitionsInternal(final String pipelineCode, final String version) {
        if (version == null) {
            return publishedPipelineRepository.findAllByCode(pipelineCode);
        }
        final PipelineDefinition pipeline = publishedPipelineRepository.findByCodeAndVersion(pipelineCode, version);
        if (pipeline != null) {
            return newArrayList(pipeline);
        }
        return emptyList();
    }

    /**
     * Removes system scripts from published pipelines because the admin UI is not concerned with them
     *
     * @return The provided published pipeline without system scripts
     */
    private PipelineDefinition removeSystemScripts(final PipelineDefinition PipelineDefinition) {
        if (PipelineDefinition == null) {
            return null;
        }
        return PipelineDefinition.copy()
                .scripts(
                        PipelineDefinition.getScripts().stream()
                                .filter(script -> script.getType() == PipelineScriptType.User)
                                .collect(Collectors.toList())
                ).build();
    }

}
