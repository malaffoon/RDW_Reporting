package org.opentestsystem.rdw.admin.repository.impl;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.model.EmbargoAuditRecord;
import org.opentestsystem.rdw.admin.model.EmbargoQuery;
import org.opentestsystem.rdw.admin.model.EmbargoUpdate;
import org.opentestsystem.rdw.admin.model.TestResultAvailability;
import org.opentestsystem.rdw.admin.model.TestResultsReportType;
import org.opentestsystem.rdw.admin.model.TestResultsStatus;
import org.opentestsystem.rdw.admin.repository.EmbargoAuditRepository;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.DataRetrievalFailureException;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.admin.model.TestResultsReportType.Aggregate;
import static org.opentestsystem.rdw.admin.model.TestResultsReportType.Individual;
import static org.opentestsystem.rdw.admin.model.TestResultsStatus.Loading;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.UNMATCHABLE_IDS;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.nullOrEmptyToDefault;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;
import static org.opentestsystem.rdw.reporting.common.util.CollectionUtils.safeIsEmpty;

@Repository
public class JdbcEmbargoRepository implements EmbargoRepository, EmbargoAuditRepository {
    // ORDER BY clause for embargo results must be added dynamically.
    private final static String OrderByPlaceholder = "{ORDER_BY_PLACEHOLDER}";

    // This should be a subset of the fields selected in findTestResultsAvailability SQL
    private final static List<String> SortableFields = Arrays.asList(
        "school_year", "district_name", "district_id", "subject_code", "subject_id", "report_type", "status");

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.embargo.findAllBySchoolYear}")
    private String findAllBySchoolYearQuery;

    @Value("${sql.embargo.findOneBySchoolYearAndState}")
    private String findOneBySchoolYearAndState;

    @Value("${sql.embargo.findOneBySchoolYearAndDistrict}")
    private String findOneBySchoolYearAndDistrict;

    @Value("${sql.embargo.findTestResultsAvailability}")
    private String findTestResultsAvailability;

    @Value("${sql.embargo.findTestResultsAvailabilityDefaultOrdering}")
    private String findTestResultsAvailabilityDefaultOrdering;

    @Value("${sql.embargo.findEmbargoAuditRecords}")
    private String findEmbargoAuditRecords;

    @Value("${sql.embargo.createState}")
    private String createState;

    @Value("${sql.embargo.createDistrict}")
    private String createDistrict;

    @Value("${sql.embargo.updateState}")
    private String updateState;

    @Value("${sql.embargo.updateDistrict}")
    private String updateDistrict;

    @Value("${sql.embargo.createEmbargo}")
    private String createEmbargo;

    @Value("${sql.embargo.updateEmbargoIndividualStatus}")
    private String updateEmbargoIndividualStatus;

    @Value("${sql.embargo.updateEmbargoAggregateStatus}")
    private String updateEmbargoAggregateStatus;


    public static final List<Integer> UNMATCHABLE_STATUSES = ImmutableList.of(-1);

    @Autowired
    public JdbcEmbargoRepository(@Qualifier("warehouseJdbcTemplate") final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public Collection<Embargo> findAllBySchoolYear(final int schoolYear, final Collection<Long> districtIds) {
        // the query returns multiple rows per organization, each having different subject_id and count
        // create builders while iterating result set, indexing them off of organization id
        final Map<Long, Embargo.Builder> builderMap = new HashMap<>();
        template.query(findAllBySchoolYearQuery,
                new MapSqlParameterSource()
                        .addValue("district_ids", nullOrEmptyToDefault(districtIds, UNMATCHABLE_IDS))
                        .addValue("school_year", schoolYear), (rs, rowNum) -> {
                    final Long id = getNullable(rs, rs.getLong("org_id"));
                    final Embargo.Builder builder = builderMap.computeIfAbsent(id, innerId -> {
                        try {
                            final Embargo.Builder innerBuilder = Embargo.builder()
                                    .organizationType(OrganizationType.valueOf(rs.getString("org_type")))
                                    .organizationId(innerId)
                                    .organizationName(rs.getString("org_name"))
                                    .individualEnabled(getNullable(rs, rs.getBoolean("individual")))
                                    .aggregateEnabled(getNullable(rs, rs.getBoolean("aggregate")))
                                    .schoolYear(rs.getInt("school_year"));

                            return innerBuilder;
                        } catch (SQLException e) {
                            throw new DataRetrievalFailureException(e.getMessage());
                        }
                    });

                    final String subjectCode = rs.getString("subject_code");
                    if (subjectCode != null) {
                        builder.examCount(rs.getString("subject_code"), rs.getLong("count"));
                    }

                    return builder;
                }
        );
        return builderMap.values().stream().map(Embargo.Builder::build).collect(Collectors.toList());
    }

    @Override
    public Embargo findOneBySchoolYearAndState(final int schoolYear) {
        return template.query(findOneBySchoolYearAndState,
                new MapSqlParameterSource()
                        .addValue("school_year", schoolYear),
                EmbargoExtractor);
    }

    @Override
    public Embargo findOneBySchoolYearAndDistrictId(final int schoolYear, final long districtId) {
        return template.query(findOneBySchoolYearAndDistrict,
                new MapSqlParameterSource()
                        .addValue("district_id", districtId)
                        .addValue("school_year", schoolYear),
                EmbargoExtractor);
    }

    @Override
    public List<TestResultAvailability> findTestResultsAvailability(final EmbargoQuery query) {
        final String orderBySql = getOrderBy(query.getSortField(), query.isDescending());
        final String enhancedSql = addOrdering(findTestResultsAvailability, orderBySql);

        return template.query(
            enhancedSql,
            getSqlParameterSource(query),
            (row, index) -> mapToTestResults(row)
        );
    }

    @Override
    public int countByQuery(final EmbargoQuery query) {
        // Remove any page limits to ensure we get the proper count.
        final EmbargoQuery noLimitsQuery = query.copy().rowOffset(0).pageSize(Integer.MAX_VALUE).build();

        // Convert existing SQL to count rows.
        final String sql = String.format("select count(*) from (%s) as results",
            addOrdering(findTestResultsAvailability, " "));

        return template.queryForObject(
            sql,
            getSqlParameterSource(noLimitsQuery),
            Integer.class
        );
    }

    private MapSqlParameterSource getSqlParameterSource(final EmbargoQuery query) {
        return new MapSqlParameterSource()
            .addValue("statuses", nullOrEmptyToDefault(query.getStatusValues(), UNMATCHABLE_STATUSES))
            .addValue("filter_by_year", query.getSchoolYear() != null)
            .addValue("year", query.getSchoolYear())
            .addValue("filter_by_district", !safeIsEmpty(query.getDistrictIds()))
            .addValue("district_ids", nullOrEmptyToDefault(query.getDistrictIds(), UNMATCHABLE_IDS))
            .addValue("filter_by_subject", query.getSubjectId() != null)
            .addValue("subject_id", query.getSubjectId())
            .addValue("filter_by_report_type", query.getReportType() != null)
            .addValue("report_type", query.getReportTypeValue())
            .addValue("page_size", query.getPageSize())
            .addValue("offset", query.getRowOffset());
    }

    private String getOrderBy(final String sortField, final boolean descending) {
        // If no ordering has been set on the client, then sort by default order.
        if (sortField == null || !SortableFields.contains(sortField)) {
            return this.findTestResultsAvailabilityDefaultOrdering;
        }

        // Special case for status sort because two statuses are stored in the same db record
        final String sortByParam  = sortField.equalsIgnoreCase("status") ?
            "IF(report_type='Individual', individual, aggregate)" : sortField;

        // Order by the client-selected field
        return String.format("ORDER BY %s %s ", sortByParam, descending ? "DESC" : "");
    }

    // Prepared statements don't have support for parametrized "ORDER BY" clauses,
    // so we have to make just this part of the query dynamically built.
    // Note: the query is also doing pagination, so it's not possible to sort outside the query.
    private String addOrdering(final String sql,  final String orderBySql) {
        return sql.replace(OrderByPlaceholder, orderBySql);
    }

    @Override
    public List<EmbargoAuditRecord> findEmbargoAuditRecords(final Date startDate) {
        return template.query(
            findEmbargoAuditRecords,
            new MapSqlParameterSource()
                .addValue("start_date", startDate),
            (row, index) -> mapToEmbargoAuditRecord(row)
        );
    }

    @Override
    public void create(final Embargo embargo, final String username) {
        try {
            if (1 != template.update((embargo.getOrganizationType() == State) ? createState : createDistrict,
                    toSource(embargo, username))) {
                throw new IllegalArgumentException("Error creating embargo");
            }
        } catch (final DataIntegrityViolationException e) {
            throw new IllegalArgumentException("Exception creating embargo", e);
        }
    }

    @Override
    public void update(final Embargo embargo, final String username) {
        final int count = template.update((embargo.getOrganizationType() == State) ? updateState : updateDistrict,
                toSource(embargo, username));
        if (count != 1) {
            throw new IllegalArgumentException("Failed to update embargo");
        }
    }

    @Override
    @Transactional(transactionManager = "warehouseTxManager")
    public int update(final EmbargoUpdate embargo, final String username) {
        int updated = 0;

        final boolean filterByReportType = embargo.getReportType() != null;
        // New records may need to be created if transitioning from Loading
        if (embargo.getStatus() == Loading) {
            int count = template.update(createEmbargo, toCreateSource(embargo, username));

            // If not limited to a single report type, count the records affected as double
            updated += (filterByReportType ? count : 2 * count);
        }

        // Update existing records with new status
        if (!filterByReportType || embargo.getReportType() == Individual) {
            updated += template.update(updateEmbargoIndividualStatus, toUpdateSource(embargo, username));
        }
        if (!filterByReportType || embargo.getReportType() == Aggregate) {
            updated += template.update(updateEmbargoAggregateStatus, toUpdateSource(embargo, username));
        }

        return updated;
    }

    private MapSqlParameterSource toSource(final Embargo embargo, final String username) {
        return new MapSqlParameterSource()
            .addValue("district_id", embargo.getOrganizationId())
            .addValue("school_year", embargo.getSchoolYear())
            .addValue("individual", embargo.isIndividualEnabled())
            .addValue("aggregate", embargo.isAggregateEnabled())
            .addValue("updated_by", username);
    }

    private SqlParameterSource toUpdateSource(final EmbargoUpdate embargo,
                                              final String username) {
        return toSource(embargo, username)
            .addValue("current_status", embargo.getStatus().getStatusCode())
            .addValue("new_status", embargo.getNewStatus().getStatusCode());
    }

    private SqlParameterSource toCreateSource(final EmbargoUpdate embargo, final String username) {
        final TestResultsStatus newIndividual = embargo.getReportType() == Aggregate ? Loading : embargo.getNewStatus();
        final TestResultsStatus newAggregate = embargo.getReportType() == Individual ? Loading : embargo.getNewStatus();

        return toSource(embargo, username)
                .addValue("individual", newIndividual.getStatusCode())
                .addValue("aggregate", newAggregate.getStatusCode());
    }

    private MapSqlParameterSource toSource(final EmbargoUpdate embargo, final String username) {
        return new MapSqlParameterSource()
            .addValue("school_year", embargo.getSchoolYear())
            .addValue("subject_id", embargo.getSubjectId())
            .addValue("filter_by_district", !safeIsEmpty(embargo.getDistrictIds()))
            .addValue("district_ids", nullOrEmptyToDefault(embargo.getDistrictIds(), UNMATCHABLE_IDS))
            .addValue("updated_by", username);
    }

    private static final ResultSetExtractor<Embargo> EmbargoExtractor = rs -> rs.next() ? Embargo.builder()
            .organizationType(OrganizationType.valueOf(rs.getString("org_type")))
            .organizationId(getNullable(rs, rs.getLong("org_id")))
            .organizationName(rs.getString("org_name"))
            .individualEnabled(getNullable(rs, rs.getBoolean("individual")))
            .aggregateEnabled(getNullable(rs, rs.getBoolean("aggregate")))
            .schoolYear(rs.getInt("school_year"))
            .readOnly(false)
            .build() : null;

    private TestResultAvailability mapToTestResults(final ResultSet row) throws SQLException {
        return TestResultAvailability.builder()
            .districtId(row.getLong("district_id"))
            .districtName(row.getString("district_name"))
            .schoolYear(row.getInt("school_year"))
            .subjectId(row.getLong("subject_id"))
            .subjectCode(row.getString("subject_code"))
            .individualStatus(TestResultsStatus.valueOf(row.getInt("individual")))
            .aggregateStatus(TestResultsStatus.valueOf(row.getInt("aggregate")))
            .reportType(TestResultsReportType.caseInsensitiveValueOf(row.getString("report_type")))
            .examCount(row.getInt("exam_count"))
            .build();
    }

    private EmbargoAuditRecord mapToEmbargoAuditRecord(final ResultSet row) throws SQLException {
        return EmbargoAuditRecord.builder()
            .schoolYear(row.getInt("school_year"))
            .district(row.getString("district"))
            .subject(row.getString("subject"))
            .individualStatus(TestResultsStatus.valueOf(row.getInt("individual")))
            .previousIndividualStatus(TestResultsStatus.valueOf(row.getInt("previous_individual")))
            .aggregateStatus(TestResultsStatus.valueOf(row.getInt("aggregate")))
            .previousAggregateStatus(TestResultsStatus.valueOf(row.getInt("previous_aggregate")))
            .user(row.getString("user"))
            .updated(row.getTimestamp("updated"))
            .build();
    }
}
