package org.opentestsystem.rdw.admin.multitenant.administration.impl;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.admin.multitenant.administration.SandboxArchiveRemovalService;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationMessage;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationProcessor;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationRequestType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusContext;
import org.opentestsystem.rdw.admin.multitenant.configserver.ConfigServerClient;
import org.opentestsystem.rdw.admin.multitenant.database.TenantDatabaseAdminOrchestrationService;
import org.opentestsystem.rdw.admin.multitenant.git.TenantConfigurationPersistenceException;
import org.opentestsystem.rdw.admin.multitenant.git.TenantConfigurationPersistenceService;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.security.UserTenant;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.messaging.support.GenericMessage;
import org.springframework.messaging.support.MessageBuilder;

import java.util.HashMap;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.isA;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.withSettings;

public class DefaultTenantAdministrationRequestHandlerTest {

    private DefaultTenantAdministrationRequestHandler defaultTenantAdministrationRequestHandler;

    private DefaultTenantAdministrationStatusService statusService;
    private MessageSecurityService messageSecurityService;
    private TenantAdministrationProcessor tenantAdministrationProcessor;
    private TenantDatabaseAdminOrchestrationService tenantDatabaseAdminOrchestrationService;
    private TenantConfigurationPersistenceService tenantConfigurationPersistenceService;
    private ConfigServerClient configServerClient;
    private SandboxArchiveRemovalService sandboxArchiveRemovalService;
    private SubscribableChannel tenantAdministrationInput;
    private MessageChannel tenantAdministrationOutput;
    private User user;

    @Before
    public void setUp() {
        messageSecurityService = mock(MessageSecurityService.class);
        tenantAdministrationInput = mock(SubscribableChannel.class);
        tenantAdministrationOutput = mock(MessageChannel.class);

        user = User.builderExt()
                .id("test")
                .username("test")
                .tenant(UserTenant.builder()
                        .sandbox(false)
                        .id("XX")
                        .build())
                .build();

        tenantAdministrationProcessor = new TenantAdministrationProcessor() {

            @Override
            public SubscribableChannel tenantAdministrationInput() {
                return tenantAdministrationInput;
            }

            @Override
            public MessageChannel tenantAdministrationOutput() {
                return tenantAdministrationOutput;
            }
        };
        tenantDatabaseAdminOrchestrationService = mock(TenantDatabaseAdminOrchestrationService.class, withSettings().verboseLogging());
        tenantConfigurationPersistenceService = mock(TenantConfigurationPersistenceService.class, withSettings().verboseLogging());
        configServerClient = mock(ConfigServerClient.class, withSettings().verboseLogging());
        sandboxArchiveRemovalService = mock(SandboxArchiveRemovalService.class, withSettings().verboseLogging());

        statusService = new DefaultTenantAdministrationStatusService();
        defaultTenantAdministrationRequestHandler = new DefaultTenantAdministrationRequestHandler(
                messageSecurityService,
                tenantAdministrationProcessor,
                tenantDatabaseAdminOrchestrationService,
                tenantConfigurationPersistenceService,
                configServerClient,
                statusService,
                sandboxArchiveRemovalService) {
            @Override
            User getCurrentUser() {
                return user;
            }
        };
        Message<Object> mockMessage = MessageBuilder.createMessage(new TenantAdministrationMessage(), new MessageHeaders(new HashMap<>()));
        when(messageSecurityService.withUser(any(), any())).thenReturn(mockMessage);
    }

    @Test
    public void createTenant() {
        defaultTenantAdministrationRequestHandler.createTenant(new TenantConfiguration());
        verify(tenantAdministrationOutput).send(isA(GenericMessage.class));
    }

    @Test
    public void createTenantAsync() {
        TenantConfiguration tenantConfiguration = TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .id("XX")
                        .key("XX")
                        .build())
                .build();
        final Message<TenantAdministrationMessage> message = createMessage(tenantConfiguration, TenantAdministrationRequestType.CREATE_TENANT);

        defaultTenantAdministrationRequestHandler.tenantAdministrationDispatcher(message);
        verify(tenantDatabaseAdminOrchestrationService).createTenantDatabases(any());
        verify(tenantConfigurationPersistenceService).saveTenantConfiguration(any());
        verify(configServerClient).postMonitor();
    }

    @Test
    public void createTenantAsyncFail() {
        TenantConfiguration tenantConfiguration = TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .id("XX")
                        .key("XX")
                        .build())
                .build();
        final Message<TenantAdministrationMessage> message = createMessage(tenantConfiguration, TenantAdministrationRequestType.CREATE_TENANT);

        doThrow(new RuntimeException("Database schema XX already exists")).when(tenantDatabaseAdminOrchestrationService).createTenantDatabases(any());
        defaultTenantAdministrationRequestHandler.tenantAdministrationDispatcher(message);

        Optional<TenantAdministrationStatusContext> statusContextOpt = statusService.findStatus("XX");
        assertThat(statusContextOpt).isPresent();
        statusContextOpt.ifPresent(statusContext -> {
            assertThat(statusContext.getTenantAdministrationStatus()).isEqualTo(TenantAdministrationStatus.CREATE_FAILED);
            assertThat(statusContext.getMessage()).contains("Create Tenant failed on step CREATE_SETTING_UP_DATABASES for reason: Database schema XX already exists");
            assertThat(statusContext.getStackTrace()).contains("Database schema XX already exists");
        });
    }

    @Test
    public void deleteTenant() {
        defaultTenantAdministrationRequestHandler.deleteTenant(new TenantConfiguration());
        verify(tenantAdministrationOutput).send(isA(GenericMessage.class));
    }

    @Test
    public void deleteTenantAsync() {
        TenantConfiguration tenantConfiguration = TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .sandbox(false)
                        .id("XX")
                        .key("XX")
                        .build())
                .build();
        defaultTenantAdministrationRequestHandler.tenantAdministrationDispatcher(createMessage(tenantConfiguration, TenantAdministrationRequestType.DELETE_TENANT));
        verify(tenantConfigurationPersistenceService).deleteTenant(tenantConfiguration.getTenant().getKey());
        verify(configServerClient).postMonitor();
    }

    @Test
    public void deleteTenantAsyncFail() {
        TenantConfiguration tenantConfiguration = TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .sandbox(false)
                        .id("XX")
                        .key("XX")
                        .build())
                .build();

        doThrow(new TenantConfigurationPersistenceException("Unable to delete tenant XX")).when(tenantConfigurationPersistenceService).deleteTenant(tenantConfiguration.getTenant().getKey());
        defaultTenantAdministrationRequestHandler.tenantAdministrationDispatcher(createMessage(tenantConfiguration, TenantAdministrationRequestType.DELETE_TENANT));

        Optional<TenantAdministrationStatusContext> statusContextOpt = statusService.findStatus("XX");
        assertThat(statusContextOpt).isPresent();
        statusContextOpt.ifPresent(statusContext -> {
            assertThat(statusContext.getTenantAdministrationStatus()).isEqualTo(TenantAdministrationStatus.DELETE_FAILED);
            assertThat(statusContext.getMessage()).contains("Delete Tenant failed on step DELETE_PERSISTING_CONFIGURATION for reason: Unable to delete tenant XX");
            assertThat(statusContext.getStackTrace()).contains("Unable to delete tenant XX");
        });
    }

    @Test
    public void createSandbox() {
        defaultTenantAdministrationRequestHandler.createSandbox(new TenantConfiguration());
        verify(tenantAdministrationOutput).send(isA(GenericMessage.class));
    }

    @Test
    public void createSandboxAsync() {
        TenantConfiguration tenantConfiguration = TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .id("XX")
                        .key("XX")
                        .build())
                .build();
        defaultTenantAdministrationRequestHandler.tenantAdministrationDispatcher(createMessage(tenantConfiguration, TenantAdministrationRequestType.CREATE_SANDBOX));
        verify(tenantDatabaseAdminOrchestrationService).createSandboxDatabases(any());
        verify(tenantConfigurationPersistenceService).saveTenantConfiguration(any());
        verify(configServerClient).postMonitor();
    }

    @Test
    public void deleteSandbox() {
        defaultTenantAdministrationRequestHandler.deleteSandbox(new TenantConfiguration());
        verify(tenantAdministrationOutput).send(isA(GenericMessage.class));
    }

    @Test
    public void deleteSandboxAsync() {
        TenantConfiguration tenantConfiguration = TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .sandbox(true)
                        .id("XX")
                        .key("XX")
                        .build())
                .build();
        defaultTenantAdministrationRequestHandler.tenantAdministrationDispatcher(createMessage(tenantConfiguration, TenantAdministrationRequestType.DELETE_SANDBOX));
        verify(sandboxArchiveRemovalService).remove(tenantConfiguration.getTenant().getKey());
        verify(tenantDatabaseAdminOrchestrationService).deleteSandboxDatabases(any());
        verify(tenantConfigurationPersistenceService).deleteSandbox(tenantConfiguration.getTenant().getKey());

        verify(configServerClient).postMonitor();
    }

    private Message<TenantAdministrationMessage> createMessage(TenantConfiguration tenantConfiguration,
                                                               TenantAdministrationRequestType tenantAdministrationRequestType) {
        TenantAdministrationMessage payload = TenantAdministrationMessage.builder()
                .tenantAdministrationRequestType(tenantAdministrationRequestType)
                .tenantConfiguration(tenantConfiguration)
                .build();

        return MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>()));
    }
}
