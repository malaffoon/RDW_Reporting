package org.opentestsystem.rdw.admin.repository.impl;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.admin.model.AssessmentQuery;
import org.opentestsystem.rdw.admin.repository.RepositoryIT;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.Assessment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.SqlConfig;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;

import static com.google.common.collect.ImmutableList.of;
import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@RepositoryIT
@ContextConfiguration(classes = ReportingJdbcAssessmentRepository.class)
@Sql(
        config = @SqlConfig(dataSource = "reportingDatasource", transactionManager = "reportingTxManager"),
        scripts = {"classpath:assessment-test-data.sql"}
)
@Transactional(transactionManager = "reportingTxManager")
public class ReportingJdbcAssessmentRepositoryIT {

    @Autowired
    private ReportingJdbcAssessmentRepository repository;

    @Test
    public void itShouldFindAllAssessments() {
        final AssessmentQuery allAssessmentsQuery = AssessmentQuery.builder()
                .limit(Integer.MAX_VALUE)
                .build();

        final Collection<Assessment> assessments = repository.findAll(allAssessmentsQuery);
        assertThat(assessments.stream().map(Assessment::getId))
                .containsOnly(-1, -2, -3, -4);
    }

    @Test
    public void itShouldLimitResults() {
        final AssessmentQuery twoAssessmentsQuery = AssessmentQuery.builder()
                .limit(2)
                .build();
        assertThat(repository.findAll(twoAssessmentsQuery)).hasSize(2);
    }

    @Test
    public void itShouldFilterByLabel() {
        final AssessmentQuery sumAssessmentsQuery = AssessmentQuery.builder()
                .label("sum")
                .build();
        assertThat(repository.findAll(sumAssessmentsQuery).stream().map(Assessment::getLabel))
                .containsOnly("sum1", "sum2");

        final AssessmentQuery minimalAssessmentQuery = AssessmentQuery.builder()
                .label("1")
                .build();
        assertThat(repository.findAll(minimalAssessmentQuery).stream().map(Assessment::getLabel))
                .containsOnly("ica1", "iab1", "sum1");
    }

    @Test
    public void itShouldFilterByName() {
        final AssessmentQuery sumAssessmentsQuery = AssessmentQuery.builder()
                .name("sum")
                .build();
        assertThat(repository.findAll(sumAssessmentsQuery).stream().map(Assessment::getName))
                .containsOnly("sum1", "sum2");

        final AssessmentQuery minimalAssessmentQuery = AssessmentQuery.builder()
                .name("1")
                .build();
        assertThat(repository.findAll(minimalAssessmentQuery).stream().map(Assessment::getName))
                .containsOnly("ica1", "iab1", "sum1");
    }

    @Test
    public void itShouldFullyPopulateAnAssessment() {
        final AssessmentQuery sumAssessmentsQuery = AssessmentQuery.builder()
                .label("sum1")
                .build();

        final Assessment result = repository.findAll(sumAssessmentsQuery).stream()
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("No results found"));

        assertThat(result)
                .isEqualToComparingFieldByFieldRecursively(Assessment.builder()
                        .id(-3)
                        .name("sum1")
                        .label("sum1")
                        .type(AssessmentType.SUMMATIVE)
                        .subjectCode("Math")
                        .gradeCode("g1")
                        .schoolYear(1997)
                        .claimCodes(of("sum_claim1", "sum_claim2", "sum_claim3"))
                        .build());
    }
}