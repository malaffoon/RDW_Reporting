
package org.opentestsystem.rdw.olap.repository.impl;

import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.AggregateRowReportResult;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.model.ReportTemplate;
import org.opentestsystem.rdw.olap.model.SqlQueryWithReportTemplate;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.EmbargoRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.repository.ReportRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.query.AbstractSqlQueryWithReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.template.SimpleReportTemplateProvider;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.caseInsensitiveValue;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;

/**
 * This class represents common functionality for implementations of {@link ReportRepository}
 */
@SuppressWarnings("unchecked")
abstract class AbstractReportRepository
        <T extends AggregateRow, R extends AggregateRowReportResult<T>, Q extends OrganizationTypeQuery, B extends AggregateRowReportResult.Builder<T, B, R>>
        implements ReportRepository<T, R, Q> {

    // this is odd, and there is probably a better way to do it, but here is why it is here:
    // not all queries support claims and this is used to indicate a query without claim when deriving an estimated row count (for
    // a report without claims) or when creating an empty template report
    private static final Set<String> noClaimCodes = newHashSet((String) null);

    private final ReportingSystemSettings systemSettings;
    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final QueryProviderRepositoryHelper reportQueryRepositoryHelper;
    private final OrganizationRepository organizationRepository;
    private final EmbargoRepository embargoRepository;
    private final ActiveAssessmentRepository activeAssessmentRepository;

    private final QueryProvider queryProvider;
    private final Organization state;
    private final int organizationPartitionSize;

    /**
     * Constructor
     */
    AbstractReportRepository(final ReportingSystemSettings systemSettings,
                             final JdbcTemplate jdbcTemplate,
                             final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                             final OrganizationRepository organizationRepository,
                             final ActiveAssessmentRepository activeAssessmentRepository,
                             final QueryProvider queryProvider,
                             final EmbargoRepository embargoRepository,
                             final int jdbcFetchSize,
                             final int organizationPartitionSize) {
        this.systemSettings = systemSettings;
        jdbcTemplate.setFetchSize(jdbcFetchSize);
        this.jdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);
        this.reportQueryRepositoryHelper = reportQueryRepositoryHelper;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.organizationRepository = organizationRepository;
        this.embargoRepository = embargoRepository;
        this.queryProvider = queryProvider;
        this.organizationPartitionSize = organizationPartitionSize;
        this.state = Organization.builder().name(systemSettings.getState().getName()).organizationType(OrganizationType.State).build();
    }

    /**
     * @return an instance of the {@link AggregateRowReportResult.Builder} of the appropriate sub-type
     */
    protected abstract B getReportBuilder();

    /**
     * @return an instance of an {@link AggregateRow} from the given data
     */
    protected abstract T buildEmptyReportRow(Organization organization, ActiveAssessment assessment, Dimension dimension, Q query, String claimCode);

    /**
     * Builds a report row from the given parameters
     */
    protected abstract T buildReportRow(ResultSet resultSet, Q query) throws SQLException;

    /**
     * Returns an instance of {@link AbstractSqlQueryWithReportTemplateProvider}
     */
    protected abstract <P extends SimpleReportTemplateProvider>
    AbstractSqlQueryWithReportTemplateProvider<Q, P> getQueryReportTemplateProvider(Organization state,
                                                                                    int organizationPartitionSize,
                                                                                    QueryProvider queryProvider,
                                                                                    QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                                                                                    PermissionSource permissionSource);

    /**
     * Returns an instance of {@link SimpleReportTemplateProvider}
     */
    protected abstract <P extends SimpleReportTemplateProvider> P
    getReportTemplateProvider(Organization state, QueryProviderRepositoryHelper reportQueryRepositoryHelper);

    /**
     * Returns an instance of {@link ReportRowIdentity}.
     * This provides a default implementations while allowing for customization by a sub-class
     *
     * @param reportRow                      an instance of the {@link AggregateRow} to derive an identity from
     * @param considerAsmtIdAsPartOfIdentity a flag indicating if assessment id is considered to be a part of a row identity
     * @return an instance of {@link ReportRowIdentity}
     */
    protected ReportRowIdentity createReportRowIdentity(final T reportRow, final boolean considerAsmtIdAsPartOfIdentity) {
        return new ReportRowIdentity(reportRow, considerAsmtIdAsPartOfIdentity);
    }

    @Override
    public R findByOrganizationType(@NotNull final PermissionSource permissionSource,
                                    @NotNull final Q query,
                                    @NotNull final OrganizationType groupByOrganizationType) {
        validate(query);

        final SqlQueryWithReportTemplate sqlQueryWithReportTemplate =
                getQueryReportTemplateProvider(state, organizationPartitionSize, queryProvider, reportQueryRepositoryHelper, permissionSource)
                        .toQuery(query, groupByOrganizationType);

        final boolean considerAsmtIdAsPartOfIdentity = AssessmentType.IAB.code().equalsIgnoreCase(query.getAssessmentTypeCode());
        final Map<ReportRowIdentity, T> templateRows = buildTemplateRowsByIdentity(sqlQueryWithReportTemplate.getReportTemplate(), query, considerAsmtIdAsPartOfIdentity);
        final B reportBuilder = getReportBuilder();

        reportBuilder.rows(jdbcTemplate.query(
                sqlQueryWithReportTemplate.getSqlQuery(),
                sqlQueryWithReportTemplate.getParameterSource(),
                (row, index) -> {
                    final T r = buildReportRow(row, query);
                    if (!reportBuilder.isCreatedWhileDataEmbargoed()) {
                        reportBuilder.createdWhileDataEmbargoed(isCreatedWhileDataEmbargoed(r, query.getAssessmentTypeCode()));
                    }
                    reportBuilder.hasResults(true);
                    templateRows.remove(createReportRowIdentity(r, considerAsmtIdAsPartOfIdentity));
                    return r;
                }));

        //back-fill with the left template rows
        if (!templateRows.isEmpty()) reportBuilder.rows(templateRows.values());
        return reportBuilder.build();
    }

    @Override
    public int estimateReportRowCountByOrganizationType(@NotNull final Q query,
                                                        @NotNull final OrganizationType groupByOrganizationType) {
        validate(query);

        final ReportTemplate reportTemplate = getReportTemplateProvider(state, reportQueryRepositoryHelper).toQuery(query, groupByOrganizationType);
        final Map<ActiveAssessment, Set<String>> claimsByAssessment = getClaimsByAssessment(reportTemplate);

        return (reportTemplate.getOrganizations().size()
                * claimsByAssessment.values().stream().flatMap(Collection::stream).collect(Collectors.toList()).size()
                * (reportTemplate.getDimensions().size() + (reportTemplate.isIncludeStudentEnrolledGradeDimension() ? 1 : 0)));
    }

    protected void validate(final Q query) {
        checkArgument(query.getAssessmentTypeCode() != null, "invalid query, missing an assessment type");
        checkArgument(query.getDimensionType() != null, "invalid query, missing a dimension type");
        checkArgument(query.getOrganizationType() != null && (query.getOrganizationType() == State || query.getOrganizationType() == District || query.getOrganizationType() == OrganizationType.School), "invalid query, unsupported organization type");
        // state shouldn't have org ids, district/school must have org ids
        checkArgument(query.getOrganizationType() != State ^ query.getOrganizationIds().isEmpty(), "invalid query, district/school requires organization ids and state does not");
    }

    protected Measures measures(final ResultSet row, final String asmtTypeCode, final String prefix) throws SQLException {
        final Measures.Builder builder = Measures.builder()
                .avgScaleScore(row.getInt(prefix + "score"))
                .avgStdErr(row.getInt(prefix + "std_err"))
                .level1Count(row.getInt(prefix + "level1"))
                .level2Count(row.getInt(prefix + "level2"))
                .level3Count(row.getInt(prefix + "level3"));

        if (!AssessmentType.IAB.code().equalsIgnoreCase(asmtTypeCode)) builder.level4Count(row.getInt(prefix + "level4"));
        return builder.build();
    }

    /**
     * Returns the {@link Dimension} for the report row. If the {@link OrganizationTypeQuery#subgroupKey} is not null, then the
     * built row represents a custom filtered result.
     */
    protected Dimension buildDimension(final ResultSet row, final Q query) throws SQLException {
        return (query.getSubgroupKey() != null) ?
                Dimension.builder().type(DimensionType.Custom).code(query.getSubgroupKey()).build() :
                Dimension.builder().code(getNullable(row, row.getString("dimension_code"))).type(caseInsensitiveValue(row.getString("dimension"))).build();

    }

    protected Dimension buildDimension(final Dimension dimension, final Q query) {
        return query.getSubgroupKey() != null ?
                Dimension.builder().type(DimensionType.Custom).code(query.getSubgroupKey()).build() : dimension;
    }

    /**
     * To simplify a report SQL, we are loading assessments and organizations separately.
     * This assumes/relies on the repositories results to be cached
     */
    protected ActiveAssessment findByIdAndSchoolYear(final String assessmentTypeCode, final int assessmentId, final int schoolYear) {
        for (final ActiveAssessment activeAssessment : activeAssessmentRepository.findAllByTypeCode(assessmentTypeCode)) {
            if (activeAssessment.getId() == assessmentId && activeAssessment.getExamSchoolYear() == schoolYear)
                return activeAssessment;
        }
        throw new IllegalArgumentException("unable to find an assessment by id " + assessmentId + " and school year " + schoolYear);
    }

    /**
     * Process the row for a flag indicating that it has been generated while the data is embargo enabled.
     * This assumes that the SQL query filters out embargoed data for users that are not allowed to view it
     * and this method is only called when the data is allowed for the user.
     */
    private boolean isCreatedWhileDataEmbargoed(final AggregateRow rowToVerify, final String asmtTypeCode) {
        // embargo is only applicable to summative exams
        if (!asmtTypeCode.equalsIgnoreCase(AssessmentType.SUMMATIVE.code())) return false;

        //embargo is only applicable to the current year exams
        if (rowToVerify.getAssessment().getExamSchoolYear() != systemSettings.getSchoolYear()) return false;

        final Organization organization = rowToVerify.getOrganization();

        if (organization.getOrganizationType().equals(OrganizationType.State)) return embargoRepository.isStateEmbargoed();

        //schools inherit their district embargo flag
        final Long districtId = organization.getOrganizationType().equals(District) ? organization.getId() : ((School) organization).getDistrictId();
        return isDistrictEmbargoed(districtId);
    }

    private boolean isDistrictEmbargoed(final long districtId) {
        return embargoRepository.findAllEmbargoedDistrictIds().contains(districtId);
    }

    protected Organization findOneByIdAndType(final long id, final OrganizationType type) {
        switch (type) {
            case School:
                return organizationRepository.findMapOfSchoolsById().get(id);
            case District:
                return organizationRepository.findMapOfDistrictsByIds().get(id);
            case State:
                return state;
            default:
                throw new IllegalStateException("Not supported organization type: " + type);
        }
    }

    private Map<ReportRowIdentity, T> buildTemplateRowsByIdentity(final ReportTemplate queryWithReportTemplate,
                                                                  final Q query,
                                                                  final boolean considerAsmtIdAsPartOfIdentity) {
        final Map<ActiveAssessment, Set<String>> claimsByAssessment = getClaimsByAssessment(queryWithReportTemplate);

        final Map<ReportRowIdentity, T> reportTemplate = newHashMap();
        // a template report consists of permutations of all the organizations and assessments
        for (final Organization organization : queryWithReportTemplate.getOrganizations()) {
            for (final ActiveAssessment assessment : queryWithReportTemplate.getAssessments()) {
                for (final Dimension dimension : queryWithReportTemplate.getDimensions()) {
                    for (final String claimCode : claimsByAssessment.get(assessment)) {
                        final T row = buildEmptyReportRow(organization, assessment, dimension, query, claimCode);
                        reportTemplate.put(createReportRowIdentity(row, considerAsmtIdAsPartOfIdentity), row);
                    }
                }
            }
        }
        return reportTemplate;
    }

    /**
     * @return collection of claims from the given {@link ReportTemplate} mapped by {@link ActiveAssessment} (may not be empty).
     * A set of claims for each assessment may not be null or empty;
     * When no claims exists for an {@link ActiveAssessment}a set with one null value is mapped to that assessment.
     */
    private Map<ActiveAssessment, Set<String>> getClaimsByAssessment(final ReportTemplate reportTemplate) {
        final Map<ActiveAssessment, Set<String>> claimsByAssessment = newHashMap();
        final Map<String, Set<String>> claimCodesBySubject = reportTemplate.getClaimCodesBySubject();

        for (final ActiveAssessment activeAssessment : reportTemplate.getAssessments()) {
            if (reportTemplate.getClaimCodesBySubject().isEmpty()) {
                claimsByAssessment.put(activeAssessment, noClaimCodes);
            } else {
                if (!claimCodesBySubject.containsKey(activeAssessment.getSubjectCode())) throw new IllegalStateException("unable to find assessment for the claim subject");
                claimsByAssessment.put(activeAssessment, claimCodesBySubject.get(activeAssessment.getSubjectCode()));
            }
        }
        return claimsByAssessment;
    }

    /**
     * Provides an identity for instances of {@link AggregateRow}
     * This is used to back-filled missing reports data.
     * Note that assessment id is ignored for non IABs. Since this is used only when there is
     * no data available, it is enough to return an assessment to represent
     * a missing report row.
     */
    protected static class ReportRowIdentity {

        final Organization organization;
        final Dimension dimension;
        final String subjectCode;
        final String asmtGradeCode;
        final int examSchoolYear;
        final Integer asmtId;

        ReportRowIdentity(final AggregateRow reportRow, final boolean considerAsmtIdAsPartOfIdentity) {
            final ActiveAssessment assessment = reportRow.getAssessment();
            this.subjectCode = assessment.getSubjectCode();
            this.asmtGradeCode = assessment.getGradeCode();
            this.examSchoolYear = assessment.getExamSchoolYear();

            this.asmtId = considerAsmtIdAsPartOfIdentity ? assessment.getId() : null;

            this.organization = reportRow.getOrganization();
            this.dimension = reportRow.getDimension();
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            final ReportRowIdentity that = (ReportRowIdentity) o;
            return Objects.equals(organization, that.organization) &&
                    Objects.equals(dimension, that.dimension) &&
                    Objects.equals(subjectCode, that.subjectCode) &&
                    Objects.equals(asmtGradeCode, that.asmtGradeCode) &&
                    Objects.equals(asmtId, that.asmtId) &&
                    examSchoolYear == that.examSchoolYear;
        }

        @Override
        public int hashCode() {
            return Objects.hash(organization, dimension, subjectCode, asmtGradeCode, examSchoolYear, asmtId);
        }
    }
}