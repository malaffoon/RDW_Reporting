package org.opentestsystem.rdw.olap.stream;

import com.amazonaws.services.s3.Headers;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.olap.model.AggregateReportResult;
import org.opentestsystem.rdw.olap.service.AggregateQueryHandlerProvider;
import org.opentestsystem.rdw.reporting.common.model.AggregateRequestMessage;
import org.opentestsystem.rdw.reporting.common.model.AggregateResponseMessage;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Properties;

import static org.opentestsystem.rdw.olap.stream.AggregateRequestProcessor.AggregateRequest;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.COMPLETED;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.FAILED;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.NOT_ENOUGH_RESULTS;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.NO_RESULTS;
import static org.springframework.http.MediaType.APPLICATION_JSON;

/**
 * This component is responsible for processing aggregate report requests arriving
 * via a message.  A report is generated, persisted to the archive service, and
 * a response message is published to the response message channel.
 */
@Component
public class AggregateReports {
    private static final Logger logger = LoggerFactory.getLogger(AggregateReports.class);

    private final AggregateRequestProcessor processor;
    private final MessageSecurityService messageSecurityService;
    private final ObjectMapper objectMapper;
    private final ArchiveService archiveService;
    private final AggregateQueryHandlerProvider handlerProvider;

    @Autowired
    public AggregateReports(final AggregateRequestProcessor processor,
                            final MessageSecurityService messageSecurityService,
                            final ObjectMapper objectMapper,
                            final ArchiveService archiveService,
                            final AggregateQueryHandlerProvider handlerProvider) {
        this.processor = processor;
        this.messageSecurityService = messageSecurityService;
        this.objectMapper = objectMapper;
        this.archiveService = archiveService;
        this.handlerProvider = handlerProvider;
    }

    @StreamListener(AggregateRequest)
    public void handleAggregateRequest(final Message<AggregateRequestMessage> message) {
        final AggregateRequestMessage payload = message.getPayload();
        logger.debug("Received aggregate report request: {}", payload.getId());

        final User user;
        try {
            user = messageSecurityService.getUser(message);
        } catch (final Exception e) {
            logger.warn("Unable to get user in aggregate report message");
            sendFailure(payload.getId(), null, e.getMessage());
            return;
        }

        Path jsonFile = null;
        try {
            final AggregateReportResult<?> report = handlerProvider.findHandler(payload.getAggregateQuery())
                    .findByQuery(user, payload.getAggregateQuery());

            if (!report.isHasResults()) {
                sendNoResults(payload.getId(), user, false);
                return;
            }

            if (report.isNotEnoughResults()) {
                sendNoResults(payload.getId(), user, true);
                return;
            }

            jsonFile = Files.createTempFile(String.valueOf(payload.getId()), "json");

            objectMapper.writeValue(jsonFile.toFile(), report.getPayload());
            archiveJson(jsonFile.toFile(), payload.getResponseLocation());
            sendSuccess(payload.getId(), user, report.getResultCount(), report.isCreatedWhileDataEmbargoed());

        } catch (final Exception e) {
            logger.warn("Unable to generate aggregate report", e);
            sendFailure(payload.getId(), user, e.getMessage());

        } finally {
            if (jsonFile != null) {
                try {
                    Files.deleteIfExists(jsonFile);
                } catch (final IOException e) {
                    logger.warn("Unable to delete temporary aggregate report json file", e);
                }
            }
        }

    }

    private void archiveJson(final File jsonfile, final URI targetLocation) throws IOException {
        final Properties properties = new Properties();
        properties.put(Headers.CONTENT_LENGTH, jsonfile.length());
        properties.put(Headers.CONTENT_TYPE, APPLICATION_JSON.toString());

        try (final FileInputStream input = new FileInputStream(jsonfile)) {
            archiveService.writeResource(targetLocation.toASCIIString(), input, properties);
        }
    }

    private void sendFailure(final long requestId, final User user, final String infoMessage) {
        final AggregateResponseMessage responsePayload = AggregateResponseMessage.builder()
                .id(requestId)
                .status(FAILED)
                .message(infoMessage)
                .build();
        final Message<AggregateResponseMessage> responseMessage = messageSecurityService.withUser(
                MessageBuilder.createMessage(responsePayload, new MessageHeaders(new HashMap<>())), user);
        processor.aggregateResponse().send(responseMessage);
    }

    private void sendSuccess(final long requestId, final User user, final long resultCount, final boolean createdWhileDataEmbargoed) {
        final AggregateResponseMessage responsePayload = AggregateResponseMessage.builder()
                .id(requestId)
                .status(COMPLETED)
                .resultCount(resultCount)
                .createdWhileDataEmbargoed(createdWhileDataEmbargoed)
                .build();
        final Message<AggregateResponseMessage> responseMessage = messageSecurityService.withUser(
                MessageBuilder.createMessage(responsePayload, new MessageHeaders(new HashMap<>())), user);
        processor.aggregateResponse().send(responseMessage);
        logger.debug("Sent aggregate report success response: {}", requestId);
    }

    private void sendNoResults(final long requestId, final User user, final boolean isNotEnoughResults) {
        final AggregateResponseMessage responsePayload = AggregateResponseMessage.builder()
                .id(requestId)
                .status(isNotEnoughResults ? NOT_ENOUGH_RESULTS : NO_RESULTS)
                .build();
        final Message<AggregateResponseMessage> responseMessage = messageSecurityService.withUser(
                MessageBuilder.createMessage(responsePayload, new MessageHeaders(new HashMap<>())), user);
        processor.aggregateResponse().send(responseMessage);
        logger.debug("Sent aggregate report no results response: {}", requestId);
    }
}
