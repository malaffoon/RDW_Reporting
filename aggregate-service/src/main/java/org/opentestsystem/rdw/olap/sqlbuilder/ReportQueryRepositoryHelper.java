package org.opentestsystem.rdw.olap.sqlbuilder;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.olap.model.CodedEntity;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.BooleanRepository;
import org.opentestsystem.rdw.olap.repository.CodedEntityRepository;
import org.opentestsystem.rdw.olap.repository.EthnicityRepository;
import org.opentestsystem.rdw.olap.repository.GenderRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.repository.StrictBooleanRepository;
import org.opentestsystem.rdw.olap.repository.SubjectRepository;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.District;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Sets.newHashSet;
import static java.util.stream.Collectors.toSet;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.StudentEnrolledGrade;

/**
 * Helper to manipulate the data from different repositories into format suitable for the query builders.
 * This helpers uses multiple repositories that are expected to be `cacheable`.
 * It is only here to avoid multiple round-trips to Redshift.
 */
@Service
public class ReportQueryRepositoryHelper {

    private final OrganizationRepository organizationRepository;
    private final ActiveAssessmentRepository activeAssessmentRepository;
    private final GenderRepository genderRepository;
    private final EthnicityRepository ethnicityRepository;
    private final BooleanRepository booleanRepository;
    private final StrictBooleanRepository strictBooleanRepository;
    private final SubjectRepository subjectRepository;

    @Autowired
    public ReportQueryRepositoryHelper(final OrganizationRepository organizationRepository,
                                       final ActiveAssessmentRepository activeAssessmentRepository,
                                       final GenderRepository genderRepository,
                                       final EthnicityRepository ethnicityRepository,
                                       final BooleanRepository booleanRepository,
                                       final StrictBooleanRepository strictBooleanRepository,
                                       final SubjectRepository subjectRepository) {
        this.organizationRepository = organizationRepository;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.genderRepository = genderRepository;
        this.ethnicityRepository = ethnicityRepository;
        this.booleanRepository = booleanRepository;
        this.strictBooleanRepository = strictBooleanRepository;
        this.subjectRepository = subjectRepository;
    }

    /**
     * Finds all {@link ActiveAssessment} represented by the given {@link ReportQuery}.
     * It is used to fill in gap data in the custom aggregate report.
     *
     * @param query the {@link ReportQuery}
     * @return a set of {@link ActiveAssessment}s
     */
    public Set<ActiveAssessment> findAssessmentsForQuery(final ReportQuery query) {
        final Set<ActiveAssessment> assessments = newHashSet();
        for (final ActiveAssessment assessment : activeAssessmentRepository.findAllByTypeId(query.getAssessmentTypeId())) {
            if (query.getSchoolYears().contains(assessment.getExamSchoolYear())
                    && query.getSubjectIds().contains(toId(assessment.getSubjectCode(), subjectRepository))
                    && query.getAssessmentGradeIds().contains(assessment.getGradeId())) {
                assessments.add(assessment);
            }
        }
        return assessments;
    }

    /**
     * Return all possible values for the given {@link DimensionType} filtered based on the given {@link ReportQuery}
     * This is used to fill in the gaps of the missing data in the custom aggregate report
     *
     * @param dimensionType the {@link DimensionType}
     * @param query         the {@link ReportQuery}
     * @return all possible values for the given {@link DimensionType} filtered based on the given {@link ReportQuery}
     */
    public List<Dimension> findDimensionsByTypeAndQueryFilters(final DimensionType dimensionType, final ReportQuery query) {

        //we do not back-fill data for this dimension type
        if (dimensionType.equals(StudentEnrolledGrade)) return ImmutableList.of();

        if (dimensionType.equals(Overall)) return ImmutableList.of(new Dimension(null, Overall));

        final Set<Integer> filters = newHashSet();
        final CodedEntityRepository repository = getRepositoryAndAddFilterByDimensionType(dimensionType, query, filters);

        if (filters.isEmpty()) return repository.findAll().stream().map(g -> new Dimension(g.getCode(), dimensionType)).collect(Collectors.toList());

        return repository.findAll().stream().filter(g -> filters.contains(g.getId())).map(g -> new Dimension(g.getCode(), dimensionType)).collect(Collectors.toList());

    }

    public Set<District> findDistrictsByIds(final Set<Long> districtIds) {
        final Set<District> districts = newHashSet();
        for (final Long districtId : districtIds) {
            if (organizationRepository.findMapOfDistrictsByIds().containsKey(districtId)) {
                districts.add(organizationRepository.findMapOfDistrictsByIds().get(districtId));
            }
        }
        return districts;
    }

    public Set<School> findSchoolsByDistrictIds(final Set<Long> districtIds) {
        final Set<School> schools = newHashSet();
        for (final Long districtId : districtIds) {
            if (organizationRepository.findAllSchoolsByDistrictId().containsKey(districtId)) {
                schools.addAll(organizationRepository.findAllSchoolsByDistrictId().get(districtId));
            }
        }
        return schools;
    }

    public Set<Long> findSchoolsIdsByDistrictIds(final Set<Long> districtIds) {
        return findSchoolsByDistrictIds(districtIds).stream().map(School::getId).collect(toSet());
    }

    public Set<School> findSchoolsByIds(final Set<Long> schoolIds) {
        final Set<School> schools = newHashSet();
        for (final Long schoolId : schoolIds) {
            if (organizationRepository.findMapOfSchoolsById().containsKey(schoolId)) {
                schools.add(organizationRepository.findMapOfSchoolsById().get(schoolId));
            }
        }
        return schools;
    }

    public Collection<District> findAllDistricts() {
        return organizationRepository.findMapOfDistrictsByIds().values();
    }

    public Set<Long> findAllDistrictIds() {
        return organizationRepository.findMapOfDistrictsByIds().keySet();
    }

    public Set<Long> findAllDistrictsOfSchools(final Set<Long> schoolIds) {
        final Set<Long> districtIds = newHashSet();
        final Set<Long> schoolIdsLeftToProcess = newHashSet(schoolIds);
        final Map<Long, List<School>> schoolsByDistrictId = organizationRepository.findAllSchoolsByDistrictId();
        for (final Long districtId : schoolsByDistrictId.keySet()) {
            for (final School school : schoolsByDistrictId.get(districtId)) {
                if (schoolIds.contains(school.getId())) {
                    schoolIdsLeftToProcess.remove(school.getId());
                    districtIds.add(school.getId());
                }
                if (schoolIdsLeftToProcess.isEmpty()) return districtIds;
            }

        }
        return districtIds;
    }

    private CodedEntityRepository getRepositoryAndAddFilterByDimensionType(final DimensionType dimensionType, final ReportQuery query, Set<Integer> ids) {
        switch (dimensionType) {
            case Gender:
                ids.addAll(query.getGenderIds());
                return genderRepository;
            case Ethnicity:
                ids.addAll(query.getEthnicityIds());
                return ethnicityRepository;
            case LEP:
                ids.addAll(query.getLepIds());
                return strictBooleanRepository;
            case MigrantStatus:
                ids.addAll(query.getMigrantStatusIds());
                return booleanRepository;
            case Section504:
                ids.addAll(query.getSection504Ids());
                return booleanRepository;
            case IEP:
                ids.addAll(query.getIepIds());
                return strictBooleanRepository;
            case EconomicDisadvantage:
                ids.addAll(query.getEconomicDisadvantageIds());
                return strictBooleanRepository;
            default:
                throw new IllegalArgumentException("unsupported request to findDimensions for dimensionType " + dimensionType);
        }
    }

    private int toId(final String code, final CodedEntityRepository repository) {
        for (final CodedEntity e : repository.findAll()) {
            if (e.getCode().equals(code)) return e.getId();
        }
        throw new IllegalArgumentException("unable to find code " + code);
    }
}
