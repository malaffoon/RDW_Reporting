package org.opentestsystem.rdw.olap.repository.impl;

import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.model.ReportRowIdentity;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.repository.EmbargoRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.CustomAggregateQueryWithReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.CustomAggregateReportContextProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateReport;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.ReportRow;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Map;

import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.common.model.AggregateReport.builder;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;

@Repository
class JdbcCustomAggregateReportRowRepository implements CustomAggregateReportRepository {

    private final ReportingSystemSettings systemSettings;
    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final QueryProviderRepositoryHelper reportQueryRepositoryHelper;
    private final ActiveAssessmentRepository activeAssessmentRepository;
    private final OrganizationRepository organizationRepository;
    private final EmbargoRepository embargoRepository;
    private final QueryProvider queryProvider;
    private final Organization state;

    @Value("${app.aggregate-reports.custom-aggregate-report-repository.organization-partition-size}")
    private int organizationPartitionSize;

    @Value("${app.aggregate-reports.custom-aggregate-report-repository.jdbc-fetch-size}")
    private int jdbcFetchSize;

    @Autowired
    public JdbcCustomAggregateReportRowRepository(final ReportingSystemSettings systemSettings,
                                                  final JdbcTemplate jdbcTemplate,
                                                  final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                                                  final ActiveAssessmentRepository activeAssessmentRepository,
                                                  final OrganizationRepository organizationRepository,
                                                  final QueryProvider queryProvider,
                                                  final EmbargoRepository embargoRepository) {
        this.systemSettings = systemSettings;
        jdbcTemplate.setFetchSize(jdbcFetchSize);
        this.jdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);
        this.reportQueryRepositoryHelper = reportQueryRepositoryHelper;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.organizationRepository = organizationRepository;
        this.embargoRepository = embargoRepository;
        this.queryProvider = queryProvider;
        this.state = Organization.builder().name(systemSettings.getState().getName()).organizationType(OrganizationType.State).build();

    }

    @Override
    public AggregateReport findByOrganizationType(@NotNull final PermissionSource permissionSource,
                                                  @NotNull final OrganizationTypeQuery query,
                                                  @NotNull final OrganizationType groupByOrganizationType) {
        final QueryWithReportTemplate queryWithReportTemplate = new CustomAggregateQueryWithReportTemplateProvider(state, organizationPartitionSize, queryProvider, reportQueryRepositoryHelper, permissionSource)
                .toQuery(query, groupByOrganizationType);

        final Map<ReportRowIdentity, ReportRow> templateRows = queryWithReportTemplate.getReportTemplate();
        final String asmtTypeCode = query.getAssessmentTypeCode();
        final AggregateReport.Builder reportBuilder = builder();

        reportBuilder.rows(jdbcTemplate.query(
                queryWithReportTemplate.getSqlQuery(),
                queryWithReportTemplate.getParameterSource(),
                (row, index) -> {
                    final ReportRow r = ReportRow.builder()
                            .assessment(findByIdAndSchoolYear(asmtTypeCode, row.getInt("asmt_id"), row.getInt("school_year")))
                            .dimension(Dimension.builder().code(getNullable(row, row.getString("dimension_code"))).type(DimensionType.caseInsensitiveValue(row.getString("dimension"))).build())
                            .organization(findOneByIdAndType(row.getLong("organization_id"), OrganizationType.valueOf(row.getString("organization_type"))))
                            .measures(measures(row, asmtTypeCode))
                            .build();
                    if (!reportBuilder.isCreatedWhileDataEmbargoed()) reportBuilder.createdWhileDataEmbargoed(isCreatedWhileDataEmbargoed(r, asmtTypeCode));
                    templateRows.remove(new ReportRowIdentity(r));
                    return r;
                }));

        //back-fill missing rows
        if (!templateRows.isEmpty()) reportBuilder.rows(templateRows.values());
        return reportBuilder.build();
    }

    @Override
    public int estimateReportRowCountByOrganizationType(@NotNull final OrganizationTypeQuery query,
                                                        @NotNull OrganizationType groupByOrganizationType) {
        return new CustomAggregateReportContextProvider<>(state, reportQueryRepositoryHelper)
                .toQuery(query, groupByOrganizationType)
                .getEstimatedRowCount();
    }

    private Measures measures(final ResultSet row, final String asmtTypeCode) throws SQLException {
        final Measures.Builder builder = Measures.builder()
                .avgScaleScore(row.getInt("score"))
                .avgStdErr(row.getInt("std_err"))
                .level1Count(row.getInt("level1"))
                .level2Count(row.getInt("level2"))
                .level3Count(row.getInt("level3"));

        if (!AssessmentType.IAB.code().equalsIgnoreCase(asmtTypeCode)) builder.level4Count(row.getInt("level4"));
        return builder.build();
    }

    /**
     * Process the row for a flag indicating that it has been generated while the data is embargo enabled.
     * This assumes that the SQL query filters out embargoed data for users that are not allowed to view it
     * and this method is only called when the data is allowed for the user.
     */
    private boolean isCreatedWhileDataEmbargoed(final ReportRow rowToVerify, final String asmtTypeCode) {

        // embargo is only applicable to summative exams
        if (!asmtTypeCode.equalsIgnoreCase(AssessmentType.SUMMATIVE.code())) return false;

        //embargo is only applicable to the current year exams
        if (rowToVerify.getAssessment().getExamSchoolYear() != systemSettings.getSchoolYear()) return false;

        final Organization organization = rowToVerify.getOrganization();

        if (organization.getOrganizationType().equals(OrganizationType.State)) return embargoRepository.isStateEmbargoed();

        //schools inherit their district embargo flag
        final Long districtId = organization.getOrganizationType().equals(District) ? organization.getId() : ((School) organization).getDistrictId();
        return isDistrictEmbargoed(districtId);
    }

    private boolean isDistrictEmbargoed(final long districtId) {
        return embargoRepository.findAllEmbargoedDistrictIds().contains(districtId);
    }

    /**
     * To simplify a report SQL, we are loading assessments and organizations separately.
     * This assumes/relies on the repositories results to be cached
     */
    private ActiveAssessment findByIdAndSchoolYear(final String assessmentTypeCode, final int assessmentId, int schoolYear) {
        for (final ActiveAssessment activeAssessment : activeAssessmentRepository.findAllByTypeCode(assessmentTypeCode)) {
            if (activeAssessment.getId() == assessmentId && activeAssessment.getExamSchoolYear() == schoolYear)
                return activeAssessment;
        }
        throw new IllegalArgumentException("unable to find an assessment by id " + assessmentId + " and school year " + schoolYear);
    }

    private Organization findOneByIdAndType(final long id, final OrganizationType type) {
        switch (type) {
            case School:
                return organizationRepository.findMapOfSchoolsById().get(id);
            case District:
                return organizationRepository.findMapOfDistrictsByIds().get(id);
            case State:
                return state;
            default:
                throw new IllegalStateException("Not supported organization type: " + type);
        }
    }
}