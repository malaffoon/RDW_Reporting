package org.opentestsystem.rdw.reporting.processor.repository;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.io.IOException;
import java.net.URI;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Collection;
import java.util.List;

import static com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping.NON_FINAL;
import static org.apache.http.util.TextUtils.isBlank;

/**
 * A JDBC implementation of a ReportRepository.
 */
@Repository
public class JdbcReportRepository implements ReportRepository {
    private final static Logger logger = LoggerFactory.getLogger(JdbcReportRepository.class);

    @Value("${sql.report.insert}")
    private String insert;

    @Value("${sql.report.update}")
    private String update;

    @Value("${sql.report.findAllByUser}")
    private String findAllByUser;

    @Value("${sql.report.findAllByUserAndId}")
    private String findAllByUserAndId;

    @Value("${sql.report.findById}")
    private String findById;

    private final ObjectMapper objectMapper;
    private final NamedParameterJdbcTemplate template;

    @Autowired
    public JdbcReportRepository(final NamedParameterJdbcTemplate template,
                                final ObjectMapper objectMapper) {
        this.template = template;
        this.objectMapper = objectMapper.copy();
        this.objectMapper.enableDefaultTypingAsProperty(NON_FINAL, "@class");
    }

    @Override
    public Report insert(final Report report) {
        final GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
        final int insertCount = this.template.update(insert,
                new MapSqlParameterSource()
                        .addValue("user_login", report.getUser())
                        .addValue("job_execution_id", report.getJobExecutionId())
                        .addValue("status", report.getStatus().ordinal())
                        .addValue("report_resource_uri", uriAsString(report.getReportResourceUri()))
                        .addValue("label", report.getLabel())
                        .addValue("report_request", serializeReportRequest(report.getReportRequest()))
                        .addValue("created", Timestamp.from(report.getCreated())),
                keyHolder);

        if (insertCount != 1) {
            throw new IllegalStateException("Unable to insert report");
        }
        return Report.builder()
                .copy(report)
                .id(keyHolder.getKey().longValue())
                .build();
    }

    @Override
    public Report update(final Report report) {
        final int updated = this.template.update(update,
                new MapSqlParameterSource()
                        .addValue("id", report.getId())
                        .addValue("user_login", report.getUser())
                        .addValue("job_execution_id", report.getJobExecutionId())
                        .addValue("status", report.getStatus().ordinal())
                        .addValue("report_resource_uri", uriAsString(report.getReportResourceUri()))
                        .addValue("label", report.getLabel())
                        .addValue("report_request", serializeReportRequest(report.getReportRequest()))
                        .addValue("created", Timestamp.from(report.getCreated())));

        if (updated != 1) {
            throw new IllegalStateException("Unable to update report: " + report.getId());
        }
        return report;
    }

    @Override
    public List<Report> findByUserAndIds(final String user, final Collection<Long> reportIds) {
        final String query = reportIds.isEmpty() ? findAllByUser : findAllByUserAndId;

        return template.query(query,
                new MapSqlParameterSource()
                        .addValue("user", user)
                        .addValue("report_ids", reportIds),
                (row, rowNum) -> asReport(row)
        );
    }

    @Override
    public Report findById(final long reportId) {
        try {
            return template.queryForObject(findById,
                    new MapSqlParameterSource()
                            .addValue("report_id", reportId),
                    (row, rowNum) -> asReport(row)
            );
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }

    private String serializeReportRequest(final AbstractExamReportRequest reportRequest) {
        if (reportRequest == null) return null;

        try {
            return objectMapper.writeValueAsString(reportRequest);
        } catch (final JsonProcessingException e) {
            logger.error("Unable to serialize report request", e);
            return null;
        }
    }

    private AbstractExamReportRequest deserializeReportRequest(final String value) {
        if (isBlank(value)) return null;

        try {
            return objectMapper.readValue(value, AbstractExamReportRequest.class);
        } catch (final IOException e) {
            logger.error("Unable to deserialize report request", e);
            return null;
        }
    }

    private URI asUri(final String value) {
        if (isBlank(value)) return null;
        return URI.create(value);
    }

    private String uriAsString(final URI value) {
        if (value == null) return null;
        return value.toASCIIString();
    }

    private Report asReport(final ResultSet row) throws SQLException {
        return Report.builder()
                .id(row.getLong("id"))
                .user(row.getString("user_login"))
                .jobExecutionId(row.getLong("job_execution_id"))
                .status(ReportStatus.values()[row.getInt("status")])
                .reportResourceUri(asUri(row.getString("report_resource_uri")))
                .label(row.getString("label"))
                .reportRequest(deserializeReportRequest(row.getString("report_request")))
                .created(row.getTimestamp("created").toInstant())
                .build();
    }
}
