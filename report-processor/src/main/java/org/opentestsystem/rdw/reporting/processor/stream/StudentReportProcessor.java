package org.opentestsystem.rdw.reporting.processor.stream;

import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.IabReport;
import org.opentestsystem.rdw.reporting.processor.model.IcaSummativeReport;
import org.opentestsystem.rdw.reporting.processor.model.PrintOptions;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.repository.IabReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.IcaSummativeReportRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.opentestsystem.rdw.reporting.processor.service.ReportViewSupport;
import org.opentestsystem.rdw.reporting.processor.service.TemplateProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static java.lang.Integer.parseInt;
import static org.opentestsystem.rdw.common.model.Subject.ELA;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.PdfReportProcessor.ReportGenerateForStudentsIn;

/**
 * This writer is responsible for delegating to the appropriate ExamQueryParamsParser
 * for the Report's request, retrieving
 * the report data for the given student chunk, and writing the report into
 * temporary storage.
 * If this is the last chunk to be processed for a report, a report collation message
 * is published.
 */
@Component
public class StudentReportProcessor {
    private final static Logger logger = LoggerFactory.getLogger(StudentReportProcessor.class);

    private final Set<ExamQueryParamsParser> queryParamsParsers;
    private final IabReportRepository iabReportRepository;
    private final IcaSummativeReportRepository icaSummativeReportRepository;
    private final ReportService reportService;
    private final ReportGenerationTemporaryStorage temporaryStorage;
    private final ReportViewSupport support;
    private final TemplateProcessor templateProcessor;
    private final HtmlToPdfProcessor htmlToPdfProcessor;
    private final RetryTemplate retryTemplate;
    private final PdfReportProcessor processor;
    private final MessageSecurityService messageSecurityService;

    @Autowired
    public StudentReportProcessor(final Set<ExamQueryParamsParser> queryParamsParsers,
                                  final IabReportRepository iabReportRepository,
                                  final IcaSummativeReportRepository icaSummativeReportRepository,
                                  final ReportService reportService,
                                  final ReportGenerationTemporaryStorage temporaryStorage,
                                  final ReportViewSupport support,
                                  final TemplateProcessor templateProcessor,
                                  final HtmlToPdfProcessor htmlToPdfProcessor,
                                  final RetryTemplate retryTemplate,
                                  final PdfReportProcessor processor,
                                  final MessageSecurityService messageSecurityService) {
        this.queryParamsParsers = queryParamsParsers;
        this.iabReportRepository = iabReportRepository;
        this.icaSummativeReportRepository = icaSummativeReportRepository;
        this.reportService = reportService;
        this.temporaryStorage = temporaryStorage;
        this.support = support;
        this.templateProcessor = templateProcessor;
        this.htmlToPdfProcessor = htmlToPdfProcessor;
        this.retryTemplate = retryTemplate;
        this.processor = processor;
        this.messageSecurityService = messageSecurityService;
    }

    @StreamListener(ReportGenerateForStudentsIn)
    public void generateStudentChunkReport(final Message<ProcessStudentChunkMessage> message) {
        final ProcessStudentChunkMessage payload = message.getPayload();
        logger.debug("Received chunk report generation message for reportId: {} chunk: {}",
                payload.getReportId(),
                payload.getIndex());


        final Report report = reportService.findOneById(payload.getReportId())
                .orElseThrow(() -> new IllegalArgumentException("Unknown report: " + payload.getReportId()));
        if (report.getStatus() == ReportStatus.FAILED) return;

        final User user = messageSecurityService.getUser(message);

        final Map<Long, StudentCompositeReport> studentReports = payload.getStudents().stream()
                .collect(Collectors.toMap(
                        Student::getId,
                        student -> StudentCompositeReport.builder()
                                .student(student)
                                .build()
                ));

        final ExamQueryParams queryParams = getQueryParams(payload.getReportId(), report.getReportRequest());

        if (includeReports(AssessmentType.IAB.code(), queryParams)) {
            appendIABReports(studentReports, user, studentReports.keySet(), queryParams);
        }
        if (includeReports(AssessmentType.ICA.code(), queryParams)) {
            appendICAReports(studentReports, user, studentReports.keySet(), queryParams);
        }
        if (includeReports(AssessmentType.SUMMATIVE.code(), queryParams)) {
            appendSummativeReports(studentReports, user, studentReports.keySet(), queryParams);
        }

        final List<StudentCompositeReport> orderedReports = payload.getStudents().stream()
                .map(student -> studentReports.get(student.getId()))
                .collect(Collectors.toList());

        logger.debug("Processing report: {} chunk: {} writing html", report.getId(), payload.getIndex());
        final byte[] html = writeReportHtml(orderedReports, report.getReportRequest());

        try {
            retryTemplate.execute((RetryCallback<Void, IOException>) retryContext -> {
                try (final InputStream pdfStream = htmlToPdfProcessor.process(html, (PrintOptions) report.getReportRequest().getOptions())) {
                    //Store chunk PDF contents
                    logger.debug("Processing report: {} chunk: {} writing pdf bytes", report.getId(), payload.getIndex());
                    temporaryStorage.writeChunk(payload.getReportId(), payload.getIndex(), pdfStream);
                }
                return null;
            }, retryContext -> {
                logger.warn("Unable to convert report chunk HTML to PDF report: {} chunk: {}",
                        report.getId(),
                        payload.getIndex(),
                        retryContext.getLastThrowable());
                throw new IllegalStateException("Unable to convert report chunk HTML to PDF");
            });

            logger.debug("Report: {} Chunk: {} complete", report.getId(), payload.getIndex());
        } catch (final IOException e) {
            throw new RuntimeException(
                    "Failed to generate report chunk. ReportId: " + payload.getReportId() +
                            " ChunkIdx: " + payload.getIndex(),
                    e);
        }

        final Report completed = reportService.completeChunk(report);
        final Map<String, String> metadata = completed.getMetadata();
        final int totalChunkCount = metadata.get(TotalChunk) == null
                ? 0
                : parseInt(completed.getMetadata().get(TotalChunk));
        final int completedChunkCount = metadata.get(CompletedChunk) == null
                ? 0
                : parseInt(metadata.get(CompletedChunk));
        if (completedChunkCount == totalChunkCount) {
            publishCollationMessage(completed, user);
            logger.debug("Report: {} all chunks complete", payload.getReportId());
        }
    }


    private void appendIABReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final Map<Long, Map<Subject, IabReport>> iabReports = iabReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        examQueryParams);


        iabReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .iabEla(value.get(ELA))
                .iabMath(value.get(MATH))
                .build()

        ));
    }

    private void appendICAReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final ExamQueryParams icaQueryParams = ExamQueryParams.builder()
                .copy(examQueryParams)
                .assessmentTypeCode(AssessmentType.ICA.code())
                .build();

        final Map<Long, Map<Subject, IcaSummativeReport>> icaReports = icaSummativeReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        icaQueryParams);

        icaReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .icaEla(value.get(ELA))
                .icaMath(value.get(MATH))
                .build()
        ));
    }

    private void appendSummativeReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final ExamQueryParams sumQueryParams = ExamQueryParams.builder()
                .copy(examQueryParams)
                .assessmentTypeCode(AssessmentType.SUMMATIVE.code())
                .build();

        final Map<Long, Map<Subject, IcaSummativeReport>> summativeReports = icaSummativeReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        sumQueryParams);

        summativeReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .summitiveEla(value.get(ELA))
                .summitiveMath(value.get(MATH))
                .build()
        ));
    }

    private byte[] writeReportHtml(final List<StudentCompositeReport> orderedReports,
                                   final AbstractExamReportRequest request) {
        final Map<String, Object> model = ImmutableMap.of(
                "studentCompositeReports", orderedReports,
                "request", request,
                "support", support);

        return templateProcessor.process(
                "batch-reports",
                model,
                request.getLanguage());
    }

    private ExamQueryParams getQueryParams(final long reportId, final AbstractExamReportRequest request) {
        //Find a registered ExamQueryParamsParser that can handle the request.
        final ExamQueryParamsParser parser = queryParamsParsers.stream()
                .filter(idFetcher -> idFetcher.accept(request))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find ExamQueryParamsParser for Report: " + reportId));
        return parser.parseQueryParams(request);
    }

    private void publishCollationMessage(final Report report, final User user) {
        final ReportRequestMessage payload = ReportRequestMessage.builder()
                .reportId(report.getId())
                .build();
        final Message<ReportRequestMessage> message = messageSecurityService.withUser(
                MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>())),
                user);
        processor.collateStudentReportsOut().send(message);
    }

    private boolean includeReports(final String testType, final ExamQueryParams params) {
        return params.getAssessmentTypeCode() == null || params.getAssessmentTypeCode().equals(testType);
    }
}
