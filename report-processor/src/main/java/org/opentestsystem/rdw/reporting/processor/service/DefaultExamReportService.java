package org.opentestsystem.rdw.reporting.processor.service;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.ReportQueryType;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.web.ReportContentResource;
import org.opentestsystem.rdw.security.Permission;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;

import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.AltScore;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Claim;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.CustomAggregate;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.DistrictSchoolExport;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Group;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Longitudinal;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.SchoolGrade;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Student;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Target;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.GroupPiiRead;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.IndividualPiiRead;

@Service
class DefaultExamReportService implements ExamReportService {

    private static final Map<ReportQueryType, Set<String>> RequiredPermissionsByReportQueryType = ImmutableMap.<ReportQueryType, Set<String>>builder()
            .put(Student, ImmutableSet.of(IndividualPiiRead, GroupPiiRead))
            .put(Group, ImmutableSet.of(GroupPiiRead))
            .put(SchoolGrade, ImmutableSet.of(IndividualPiiRead))
            .put(DistrictSchoolExport, ImmutableSet.of(IndividualPiiRead))
            .put(CustomAggregate, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .put(Longitudinal, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .put(Claim, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .put(AltScore, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .put(Target, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .build();

    private final ReportGenerator generator;
    private final UserReportService service;
    private final ReportContentService contentService;

    DefaultExamReportService(final ReportGenerator generator,
                             final UserReportService service,
                             final ReportContentService contentService) {
        this.generator = generator;
        this.service = service;
        this.contentService = contentService;
    }

    @Override
    public List<UserReport> getReports(@NotNull final User user) {
        return service.findAllByUserAndId(user.getUsername(), ImmutableSet.of());
    }

    @Override
    public List<UserReport> getReports(@NotNull final User user, final Iterable<Long> reportIds) {
        return service.findAllByUserAndId(user.getUsername(), reportIds != null ? ImmutableSet.copyOf(reportIds) : ImmutableSet.of());
    }

    @Override
    public ReportContentResource openReportContent(@NotNull final User user, final long reportId) {

        final UserReport report = service.findOneById(reportId)
                .orElseThrow(NoSuchElementException::new);

        if (!report.getUser().equals(user.getUsername())) {
            throw new NoSuchElementException();
        }

        return contentService.openContent(report);
    }

    @Override
    public UserReport createReport(
            @NotNull final User user,
            @NotNull final ReportQuery query) {
        checkPermissions(user.getPermissionsById(), query.getType());
        return generator.generateReport(query, user);
    }

    @Override
    public void delete(final User user, final long id) {
        final Optional<UserReport> found = service.findOneById(id);
        if (!found.isPresent()) return;

        // even though this is a find/delete, it doesn't really need to be transactional
        service.delete(user.getUsername(), id);
        contentService.deleteContent(found.get());
    }

    private void checkPermissions(
            @NotNull final Map<String, Permission> permissionsById,
            @NotNull final ReportQueryType type) {

        final Set<String> requiredPermissions = RequiredPermissionsByReportQueryType.get(type);
        if (requiredPermissions != null
                && !requiredPermissions.isEmpty()
                && requiredPermissions.stream().noneMatch(permissionsById::containsKey)) {
            throw new RuntimeException(String.format(
                    "User needs any of permissions (%s) to create reports of type \"%s\"",
                    requiredPermissions, type
            ));
        }
    }
}
