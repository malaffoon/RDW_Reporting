package org.opentestsystem.rdw.reporting.processor.repository;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.MapDifference;
import com.google.common.collect.MapDifference.ValueDifference;
import com.google.common.collect.Maps;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.jackson.ReportModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.net.URI;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.apache.http.util.TextUtils.isBlank;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;

/**
 * A JDBC implementation of a ReportRepository.
 */
@Repository
public class JdbcReportRepository implements ReportRepository {
    private final static Logger logger = LoggerFactory.getLogger(JdbcReportRepository.class);

    @Value("${sql.report.create}")
    private String create;

    @Value("${sql.report.update}")
    private String update;

    @Value("${sql.report.deleteByIds}")
    private String deleteByIds;

    @Value("${sql.report.findAllByUser}")
    private String findAllByUser;

    @Value("${sql.report.findAllByUserAndId}")
    private String findAllByUserAndId;

    @Value("${sql.report.findById}")
    private String findById;

    @Value("${sql.report.findAllOlderThanNumberOfDays}")
    private String findAllOlderThanNumberOfDays;

    @Value("${sql.report.completeChunk}")
    private String completeChunk;

    @Value("${sql.report.findMetadataForReports}")
    private String findMetadataForReports;

    @Value("${sql.report.deleteMetadataForReport}")
    private String deleteMetadataForReport;

    @Value("${sql.report.insertMetadataForReport}")
    private String insertMetadataForReport;

    private final ObjectMapper objectMapper;
    private final NamedParameterJdbcTemplate template;

    @Autowired
    public JdbcReportRepository(final NamedParameterJdbcTemplate template,
                                final ObjectMapper objectMapper) {
        this.template = template;
        this.objectMapper = objectMapper.copy();
        this.objectMapper.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);
        this.objectMapper.registerModule(new ReportModule());
    }

    @Override
    @Transactional
    public Report create(final Report report) {
        final GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
        final int insertCount = this.template.update(create,
                new MapSqlParameterSource()
                        .addValue("user_login", report.getUser())
                        .addValue("status", report.getStatus().id())
                        .addValue("report_resource_uri", asStringOrNull(report.getReportResourceUri()))
                        .addValue("label", report.getLabel())
                        .addValue("report_request", serializeReportRequest(report.getReportRequest()))
                        .addValue("report_type", report.getReportRequest().getReportTypeDisplayValue())
                        .addValue("created", Timestamp.from(report.getCreated())),
                keyHolder);

        if (insertCount != 1) {
            throw new IllegalStateException("Unable to create report");
        }
        return Report.builder()
                .copy(report)
                .id(keyHolder.getKey().longValue())
                .build();
    }

    @Override
    @Transactional
    public Report update(final Report report) {
        final long reportId = report.getId();
        final int updated = this.template.update(update,
                new MapSqlParameterSource()
                        .addValue("id", reportId)
                        .addValue("user_login", report.getUser())
                        .addValue("status", report.getStatus().id())
                        .addValue("report_resource_uri", asStringOrNull(report.getReportResourceUri()))
                        .addValue("label", report.getLabel())
                        .addValue("report_request", serializeReportRequest(report.getReportRequest()))
                        .addValue("created", Timestamp.from(report.getCreated())));

        if (updated != 1) {
            throw new IllegalStateException("Unable to update report: " + reportId);
        }

        final Map<Long, Map<String, String>> metadataByReportId = getMetadataForReports(newArrayList(reportId));
        final Map<String, String> existingMetadata = metadataByReportId.containsKey(reportId) ? metadataByReportId.get(reportId) : newHashMap();

        final MapDifference<String, String> metadataDiff = Maps.difference(existingMetadata, report.getMetadata());

        executeMetadataForReportChanges(reportId, combineWithRightValue(metadataDiff.entriesOnlyOnLeft(), metadataDiff.entriesDiffering()), deleteMetadataForReport);
        executeMetadataForReportChanges(reportId, combineWithRightValue(metadataDiff.entriesOnlyOnRight(), metadataDiff.entriesDiffering()), insertMetadataForReport);

        return findById(reportId);
    }

    @Override
    public List<Report> findByUserAndIds(final String user, final Collection<Long> reportIds) {
        final String query = reportIds.isEmpty() ? findAllByUser : findAllByUserAndId;

        return saturateMetadata(template.query(query,
                new MapSqlParameterSource()
                        .addValue("user", user)
                        .addValue("report_ids", reportIds),
                (row, num) -> asReport(row)
        ));
    }

    @Override
    public Report findById(final long reportId) {
        return saturateMetadata(template.query(findById,
                new MapSqlParameterSource()
                        .addValue("report_id", reportId),
                (row, num) -> asReport(row)
        )).stream().findFirst().orElse(null);
    }

    @Override
    public List<Report> findAllOlderThanNumberOfDays(final int numberOfDays) {
        return saturateMetadata(template.query(findAllOlderThanNumberOfDays,
                new MapSqlParameterSource("number_of_days", numberOfDays),
                (row, num) -> asReport(row)
        ));
    }

    @Override
    public void deleteIds(final Collection<Long> ids) {
        template.update(deleteByIds, new MapSqlParameterSource("ids", ids));
    }

    @Override
    @Transactional
    public Report completeChunk(final Report report) {
        final GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
        final int updatedCount = this.template.update(completeChunk,
                new MapSqlParameterSource()
                        .addValue("report_id", report.getId()),
                keyHolder);

        if (updatedCount != 1) {
            throw new IllegalStateException("Unable to update report");
        }
        return Report.builder()
                .copy(report)
                .metadata(CompletedChunk, String.valueOf(keyHolder.getKey().intValue()))
                .build();
    }

    private void executeMetadataForReportChanges(final long reportId, final Map<String, String> valuesByName, final String sql) {
        if (!valuesByName.isEmpty()) {
            final List<SqlParameterSource> batchParameters = newArrayList();
            for (final String name : valuesByName.keySet()) {
                batchParameters.add(new MapSqlParameterSource("name", name).addValue("value", valuesByName.get(name)).addValue("report_id", reportId));
            }

            template.batchUpdate(sql, batchParameters.toArray(new SqlParameterSource[0]));
        }
    }

    private static Map<String, String> combineWithRightValue(final Map<String, String> one, final Map<String, ValueDifference<String>> another) {
        final Map<String, String> combined = newHashMap(one);
        for (final String key : another.keySet()) {
            combined.put(key, another.get(key).rightValue());
        }
        return combined;
    }

    private Map<Long, Map<String, String>> getMetadataForReports(final Collection<Long> reportIds) {
        if (reportIds.isEmpty()) return Collections.emptyMap();

        final Map<Long, Map<String, String>> metadata = new HashMap<>();

        template.query(findMetadataForReports,
                new MapSqlParameterSource("report_ids", reportIds),
                asReportMetadata(metadata)
        );
        return metadata;
    }

    private String serializeReportRequest(final AbstractExamReportRequest reportRequest) {
        if (reportRequest == null) return null;

        try {
            return objectMapper.writeValueAsString(reportRequest);
        } catch (final JsonProcessingException e) {
            logger.error("Unable to serialize report request", e);
            return null;
        }
    }

    private AbstractExamReportRequest deserializeReportRequest(final String value) {
        if (isBlank(value)) return null;

        try {
            return objectMapper.readValue(value, AbstractExamReportRequest.class);
        } catch (final IOException e) {
            logger.error("Unable to deserialize report request", e);
            return null;
        }
    }

    private List<Report> saturateMetadata(final Collection<Report> reports) {
        final Map<Long, Map<String, String>> metadata = getMetadataForReports(reports.stream()
                .map(Report::getId)
                .collect(Collectors.toSet()));

        return reports.stream()
                .map((report) -> {
                    final Map<String, String> reportMetadata = metadata.get(report.getId());
                    if (reportMetadata == null) {
                        return report;
                    }

                    return report.copy()
                            .metadata(reportMetadata)
                            .build();
                })
                .collect(Collectors.toList());
    }

    private Report asReport(final ResultSet row) throws SQLException {
        return Report.builder()
                .id(row.getLong("id"))
                .user(row.getString("user_login"))
                .status(ReportStatus.valueOf(row.getInt("status")))
                .reportResourceUri(asUriOrNull(row.getString("report_resource_uri")))
                .label(row.getString("label"))
                .reportRequest(deserializeReportRequest(row.getString("report_request")))
                .created(row.getTimestamp("created").toInstant())
                .build();
    }

    private static RowCallbackHandler asReportMetadata(final Map<Long, Map<String, String>> metadata) {
        return (row) -> {
            final Long reportId = row.getLong("report_id");
            final Map<String, String> reportMetadata = metadata.computeIfAbsent(reportId, (id) -> new HashMap<>());
            reportMetadata.put(
                    row.getString("name"),
                    row.getString("value")
            );
        };
    }

    private static URI asUriOrNull(final String value) {
        if (isBlank(value)) return null;
        return URI.create(value);
    }

    private static String asStringOrNull(final URI value) {
        if (value == null) return null;
        return value.toASCIIString();
    }
}
