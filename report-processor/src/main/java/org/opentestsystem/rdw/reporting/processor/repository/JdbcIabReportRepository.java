package org.opentestsystem.rdw.reporting.processor.repository;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.MultimapBuilder;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.jdbc.Assessments;
import org.opentestsystem.rdw.reporting.common.jdbc.Exams;
import org.opentestsystem.rdw.reporting.common.jdbc.SecurityParameterProvider;
import org.opentestsystem.rdw.reporting.common.jdbc.Students;
import org.opentestsystem.rdw.reporting.common.model.Assessment;
import org.opentestsystem.rdw.reporting.common.model.ExamWithPercentile;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.model.UserGroupType;
import org.opentestsystem.rdw.reporting.common.model.WritingTraitScores;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.UserGroupSqlProvider;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.IabReport;
import org.opentestsystem.rdw.reporting.processor.util.StudentEnrollments;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.validation.constraints.NotNull;
import java.sql.SQLException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import static com.google.common.collect.Maps.newHashMap;
import static java.util.Comparator.comparing;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.processor.util.ReportProcessorUtils.getExamFilterParameters;

@Repository
class JdbcIabReportRepository implements IabReportRepository {

    private final NamedParameterJdbcTemplate template;
    private final SecurityParameterProvider securityParameterProvider;
    private final ReportingSystemSettings systemSettings;

    private final String findAllIabsByStudentIdsAndQueryParamsUnknownPermissions;

    private final String findAllIabsForTeacherGroupByStudentIdsAndQueryParamsGroupPermissions;
    private final String findAllIabsForAdminGroupByStudentIdsAndQueryParamsGroupPermissions;


    @Autowired
    JdbcIabReportRepository(final NamedParameterJdbcTemplate template,
                            final UserGroupSqlProvider userGroupSqlProvider,
                            final SecurityParameterProvider securityParameterProvider,
                            final ReportingSystemSettings systemSettings,
                            @Value("${sql.exam.findAllIabsByStudentIdsAndQueryParamsUnknownPermissions}") final String findAllIabsByStudentIdsAndQueryParamsUnknownPermissions,
                            @Value("${sql.exam.findAllIabsByStudentIdsAndQueryParamsGroupPermissions}") final String findAllIabsByStudentIdsAndQueryParamsGroupPermissions) {
        this.template = template;
        this.securityParameterProvider = securityParameterProvider;
        this.systemSettings = systemSettings;

        this.findAllIabsByStudentIdsAndQueryParamsUnknownPermissions = findAllIabsByStudentIdsAndQueryParamsUnknownPermissions;

        this.findAllIabsForTeacherGroupByStudentIdsAndQueryParamsGroupPermissions = userGroupSqlProvider.getSqlForGroupOfType(findAllIabsByStudentIdsAndQueryParamsGroupPermissions, UserGroupType.Teacher);
        this.findAllIabsForAdminGroupByStudentIdsAndQueryParamsGroupPermissions = userGroupSqlProvider.getSqlForGroupOfType(findAllIabsByStudentIdsAndQueryParamsGroupPermissions, UserGroupType.Admin);
    }

    @Override
    public Map<Long, Map<Subject, IabReport>> findAllForStudentsByExamFilter(
            @NotNull final User user,
            final Collection<Long> studentIds,
            final ExamQueryParams examQueryParams) {

        final Map<Long, Map<Subject, IabReport.Builder>> studentReportBuilders = newHashMap();
        final Map<Long, Map<Subject, Multimap<Assessment, ExamWithPercentile>>> studentReportAssessments = new HashMap<>();
        final Map<Long, ExamWithPercentile.Builder> examBuilderMap = newHashMap();
        final Multimap<Long, String> performanceWritingTypesByExam = HashMultimap.create();
        final String query = getExamFilterQuery(examQueryParams);

        template.query(
                query,
                new MapSqlParameterSource()
                        .addValues(securityParameterProvider.getSecurityParameters(user, examQueryParams.isDisableTransferAccess()))
                        .addValues(getExamFilterParameters(examQueryParams))
                        .addValue("student_ids", studentIds),
                (row) -> {
                    // This builder depends on the exams being sorted in order of latest to oldest completion date
                    // Only in this sort order will the first row contain the most recent student enrollment information
                    // Only in this sort order will the exams associated with assessments be sorted correctly when inserting into the multimap

                    final long studentId = row.getLong("student_id");

                    // TODO:ConfigurableSubjects - eed to remove Subject enum
                    final Subject subject = Subject.valueOf(row.getString("asmt_subject_code").toUpperCase());

                    studentReportBuilders
                            .computeIfAbsent(studentId, (id) -> new HashMap<>())
                            .computeIfAbsent(subject, (sub) -> {
                                try {
                                    return IabReport.builder()
                                            .student(Students.map(row, Student.builder(), "student_").build())
                                            .studentEnrollment(StudentEnrollments.map(row, systemSettings.getState().getCode()));
                                } catch (final SQLException e) {
                                    throw new RuntimeException(e);
                                }
                            });

                    final Assessment assessment = Assessments.mapWithCutPoints(row, Assessment.builder(), "asmt_").build();
                    final long examId = row.getLong("id");
                    final ExamWithPercentile.Builder examToBuild = examBuilderMap.compute(examId, (key, examBuilder) -> {
                        try {
                            examBuilder = Exams.map(row, ExamWithPercentile.builder())
                                    .performanceWritingType(row.getString("performance_task_writing_type"))
                                    .writingTraitScores(getNullable(row, row.getInt("ei_trait_evidence_elaboration_score")) == null ? null : new WritingTraitScores(
                                                    getNullable(row, row.getInt("ei_trait_evidence_elaboration_score")),
                                                    getNullable(row, row.getInt("ei_trait_organization_purpose_score")),
                                                    getNullable(row, row.getInt("ei_trait_conventions_score"))
                                            )
                                    )
                                    .percentileMean(getNullable(row, row.getInt("percentile_mean")))
                                    .percentileRank(getNullable(row, row.getInt("percentile_rank")));
                            return examBuilder;
                        } catch (final SQLException e) {
                            throw new RuntimeException(e);
                        }
                    });

                    final ExamWithPercentile exam = examToBuild.build();
                    final Multimap<Assessment, ExamWithPercentile> examsByAssessment = studentReportAssessments
                            .computeIfAbsent(studentId, (id) -> new HashMap<>())
                            .computeIfAbsent(subject, (subj) -> MultimapBuilder
                                    .treeKeys(comparing(Assessment::getLabel))
                                    .arrayListValues()
                                    .build());

                    // We use a Hashmultimap to keep track of the exam ids and performance writing types. In practice,
                    // exams have a single writing trait question, in theory, however, they can have multiple.
                    // This assumes that we allow for a single writing trait exam item, per performance writing type
                    if (!performanceWritingTypesByExam.containsKey(exam.getId()) || exam.getPerformanceWritingType() != null) {
                        performanceWritingTypesByExam.put(exam.getId(), exam.getPerformanceWritingType());
                        examsByAssessment.put(assessment, exam);
                    }
                }
        );

        // Collate the assessments/exams into reports
        final Map<Long, Map<Subject, IabReport>> reportsByStudent = new HashMap<>();

        studentReportBuilders.forEach((key, value) -> {
            final long studentId = key;

            value.forEach((subject, builder) -> {

                final Multimap<Assessment, ExamWithPercentile> assessmentsBySubject = studentReportAssessments
                        .getOrDefault(studentId, new HashMap<>())
                        .getOrDefault(subject, ImmutableMultimap.of());
                if (assessmentsBySubject.isEmpty()) return;

                reportsByStudent
                        .computeIfAbsent(studentId, (id) -> new HashMap<>())
                        .put(subject, builder.examsByAssessment(assessmentsBySubject.asMap()).build());
            });
        });

        return reportsByStudent;
    }

    private String getExamFilterQuery(final ExamQueryParams examQueryParams) {
        switch (examQueryParams.getQueryPermissionType()) {
            case Unknown:
            case Individual:
                return findAllIabsByStudentIdsAndQueryParamsUnknownPermissions;
            case Group:
                return examQueryParams.getGroupId().getType() == UserGroupType.Admin ?
                        findAllIabsForAdminGroupByStudentIdsAndQueryParamsGroupPermissions :
                        findAllIabsForTeacherGroupByStudentIdsAndQueryParamsGroupPermissions;
            default:
                throw new IllegalArgumentException("Unknown query permission type: " + examQueryParams.getQueryPermissionType());
        }
    }

}
