package org.opentestsystem.rdw.reporting.processor.web.converter;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.opentestsystem.rdw.common.model.AssessmentBoundaries;
import org.opentestsystem.rdw.reporting.common.model.AbstractAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;
import org.opentestsystem.rdw.reporting.common.util.Headers;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.AggregateReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.ReportType;
import org.opentestsystem.rdw.reporting.processor.web.ReportContentResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageNotWritableException;

import javax.validation.constraints.NotNull;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.apache.commons.lang.StringUtils.EMPTY;
import static org.apache.commons.lang.StringUtils.isNotEmpty;
import static org.apache.commons.lang.StringUtils.trimToEmpty;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.reporting.common.util.MediaTypes.TEXT_CSV_UTF8;
import static org.opentestsystem.rdw.reporting.common.util.MediaTypes.getExtension;
import static org.springframework.http.HttpHeaders.CONTENT_DISPOSITION;
import static org.springframework.http.MediaType.APPLICATION_JSON;

/**
 * This base handler provides common functionality for converting reports consisting of a list of
 * {@link AggregateRow} JSON objects into a CSV.
 * *
 * If completeness/administrative condition filters have been applied to the query, they are printed in the first row,
 * last column of the response under the header of "Attributes."
 */
@SuppressWarnings("unchecked")
abstract class AbstractAggregateReportCsvHandler<Q extends AbstractAggregateReportQuery, R extends AggregateRow> extends DefaultReportHandler {
    private static final Logger logger = LoggerFactory.getLogger(AbstractAggregateReportCsvHandler.class);
    private static final String NotApplicable = "";
    private static final Object[] EmptyObjectArray = new Object[]{};
    private static final Locale ReportLocale = Locale.US;

    protected static final Joiner AttributeJoiner = Joiner.on("; ");
    private static final Joiner AttributeValueJoiner = Joiner.on("|");

    private final MessageSource messageSource;
    private final ObjectMapper objectMapper;

    @Autowired
    public AbstractAggregateReportCsvHandler(final MessageSource messageSource,
                                             final ObjectMapper objectMapper) {
        this.messageSource = messageSource;
        this.objectMapper = objectMapper;
    }

    @Override
    public boolean accept(final ReportContentResource resource, final MediaType requestedMediaType) {
        final AbstractExamReportRequest request = resource.getReport().getReportRequest();
        return !APPLICATION_JSON.isCompatibleWith(requestedMediaType) &&
                request.getReportType() == ReportType.AggregateReportRequest;
    }

    @Override
    protected void setHeaders(final ReportContentResource resource, final HttpHeaders headers) {
        final String filename = resource.getReport().getLabel().replaceAll("\\s", "_") + "." + getExtension(TEXT_CSV_UTF8);
        final String contentDisposition = Headers.formatContentDispositionAttachment(filename, Charset.forName("UTF-8"));

        headers.setContentType(TEXT_CSV_UTF8);
        headers.set(CONTENT_DISPOSITION, contentDisposition);
    }

    @Override
    protected void writeContent(final ReportContentResource resource, final HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
        try (final InputStream in = resource.getInputStream()) {
            final AggregateReportRequest request = (AggregateReportRequest) resource.getReport().getReportRequest();
            final Q query = (Q) request.getQuery();
            final JsonFactory jsonFactory = objectMapper.getFactory();
            final JsonParser parser = jsonFactory.createParser(in);
            if (parser.nextToken() != JsonToken.START_ARRAY) {
                throw new IllegalStateException("Found non-array json payload for aggregate report: " + resource.getReport().getId());
            }
            parser.nextToken();
            final Iterator<R> rowIterator = asReportRowIterator(parser, resource);

            printCsv(rowIterator, query, outputMessage.getBody());

        } catch (final IOException e) {
            throw new RuntimeException("Problem writing aggregate report content to response", e);
        }
    }

    private Iterator<R> asReportRowIterator(final JsonParser parser, final ReportContentResource resource) {
        return new Iterator<R>() {
            @Override
            public boolean hasNext() {
                return parser.currentToken() == JsonToken.START_OBJECT;
            }

            @Override
            public R next() {
                try {
                    final JsonNode node = objectMapper.readTree(parser);
                    parser.nextToken();
                    return objectMapper.treeToValue(node, getRowInstanceClass());
                } catch (final IOException e) {
                    throw new IllegalStateException("Unable to parse json payload for aggregate report: " + resource.getReport().getId(), e);
                }
            }
        };
    }

    private List<String> getHeaders(final Q query) {
        final List<String> headers = newArrayList();
        headers.add(getMessage("report.aggregate.export.header.organization"));
        headers.add(getMessage("report.aggregate.export.header.natural-id"));
        headers.add(getMessage("report.aggregate.export.header.assessment"));
        headers.add(getMessage("report.aggregate.export.header.assessment-type"));
        headers.add(getMessage("report.aggregate.export.header.subject"));
        headers.add(getMessage("report.aggregate.export.header.grade"));
        headers.add(getMessage("report.aggregate.export.header.year"));
        //this allows custom implementations to add headers
        headers.addAll(getReportCustomHeaders());
        headers.add(getMessage("report.aggregate.export.header.dimension"));
        headers.add(getMessage("report.aggregate.export.header.dimension-code"));
        //this allows custom implementations to add measure(s)
        headers.addAll(getMeasureHeaders(query));
        headers.add(getMessage("report.aggregate.export.header.attributes"));
        return headers;
    }

    // note that the order of the row values must match the headers order
    private List<String> getRowValues(final CsvContext context, final R result) {
        final List<String> rowValues = newArrayList();
        rowValues.add(result.getOrganization().getName());
        rowValues.add(result.getOrganization().getNaturalId());
        rowValues.add(result.getAssessment().getLabel());
        rowValues.add(context.getQuery().getAssessmentTypeCode());
        rowValues.add(result.getAssessment().getSubjectCode());
        rowValues.add(result.getAssessment().getGradeCode());
        rowValues.add(String.valueOf(result.getAssessment().getExamSchoolYear()));
        //this allows custom implementations to add values
        rowValues.addAll(getReportCustomValues(context, result));
        rowValues.add(result.getDimension().getType().code());
        //this allows custom implementations to override the dimension values
        rowValues.add(getDimensionValue(context, result.getDimension()));
        //this allows custom implementations to add measures values
        rowValues.addAll(getMeasuresValues(context, result));
        rowValues.add(context.getRowIdx() == 0 ? AttributeJoiner.join(getFirstRowAttributes(context.getQuery())) : EMPTY);
        return rowValues;
    }

    /**
     * Returns {@link StudentFilters}'s as a list of the attributes
     */
    protected static List<String> getFiltersAsAttributes(final StudentFilters filters) {
        if (filters == null) return newArrayList();

        final List<String> attributes = newArrayList();
        appendAttribute(attributes, "Sex", filters.getGenderCodes());
        appendAttribute(attributes, "Ethnicity", filters.getEthnicityCodes());
        appendAttribute(attributes, "LEPStatus", filters.getLepCodes());
        appendAttribute(attributes, "ELAS", filters.getElasCodes());
        appendAttribute(attributes, "MigrantStatus", filters.getMigrantStatusCodes());
        appendAttribute(attributes, "Section504Status", filters.getSection504Codes());
        appendAttribute(attributes, "IDEAIndicator", filters.getIepCodes());
        appendAttribute(attributes, "EconomicDisadvantageStatus", filters.getEconomicDisadvantageCodes());
        return attributes;
    }

    /**
     * Returns query data that need to be appended as attributes to the first row
     */
    private List<String> getFirstRowAttributes(final Q query) {
        final List<String> attributes = newArrayList();

        final LocalDateTime localDate = LocalDateTime.now();
        appendAttribute(attributes, "ReportDate", Collections.singleton(localDate.format(DateTimeFormatter.ISO_DATE_TIME)));
        appendAttribute(attributes, "AdministrationCondition", query.getAdministrativeConditionCodes());
        appendAttribute(attributes, "Completeness", query.getCompletenessCodes());
        if (!query.isFilteredSubgroupQuery()) attributes.addAll(getFiltersAsAttributes(query.getStudentFilters()));
        return attributes;
    }

    private String getDimensionValue(final CsvContext context, final Dimension dimension) {
        return !context.getQuery().isFilteredSubgroupQuery() ? trimToEmpty(dimension.getCode()) : getFilteredSubgroupDimensionValue(context, dimension);
    }

    /**
     * Returns a custom subgroup {@link StudentFilters} as a string of attributes
     * A subgroup is identified by the {@link Dimension#code}
     */
    private String getFilteredSubgroupDimensionValue(final CsvContext context, final Dimension dimension) {

        final String subgroupKey = dimension.getCode();

        //check the cached values first
        if (isNotEmpty(context.get(subgroupKey, String.class))) return context.get(subgroupKey, String.class);

        final String subgroupAttributesAsString = getSubgroupAsString(context, subgroupKey);
        context.put(subgroupKey, subgroupAttributesAsString);
        return subgroupAttributesAsString;
    }

    private String getSubgroupAsString(final CsvContext context, final String subgroupKey) {

        final StudentFilters subGroupStudentFilters = context.getQuery().getSubgroups().get(subgroupKey);
        if (subGroupStudentFilters != null) return AttributeJoiner.join(getFiltersAsAttributes(subGroupStudentFilters));

        // check if this is a default Overall dimension that was added without a user's explicit request
        if (DimensionType.Overall.equals(DimensionType.caseInsensitiveValue(subgroupKey))) return DimensionType.Overall.code();

        throw new IllegalStateException("Unknown subgroup referenced by FilteredSubgroup report result: " + subgroupKey);
    }

    /**
     * @return a class of a row instance
     */
    protected abstract Class<R> getRowInstanceClass();

    /**
     * @return a list of all {@link Measures} headers. This allows custom implementations to override the default behaviour
     */
    protected abstract List<String> getMeasureHeaders(final Q query);

    /**
     * @return a list of headers. This allows custom implementations to override the default behaviour.
     */
    protected List<String> getReportCustomHeaders() {
        return newArrayList();
    }

    /**
     * @return a list of all {@link Measures} values. Must be aligned with the results from getMeasureHeaders.
     * This allows custom implementations to override the default behaviour
     */
    protected abstract List<String> getMeasuresValues(final CsvContext context, final R result);

    /**
     * @return a list of values. Must be aligned with the results from getReportCustomHeaders.
     * This allows custom implementations to override the default behaviour
     */
    protected List<String> getReportCustomValues(final CsvContext context, final R result) {
        return newArrayList();
    }

    /**
     * @return a helper to return measures related values
     */
    protected static List<String> getMeasuresValues(final String asmtTypeCode, final Measures measures) {
        final List<String> measuresValues = newArrayList();
        final long studentCount = measures.getStudentCount();

        measuresValues.add(String.valueOf(studentCount));
        measuresValues.add(measures.getAvgScaleScore() == null ? NotApplicable : measures.getAvgScaleScore().toString());
        measuresValues.add(measures.getAvgStdErr() == null ? NotApplicable : measures.getAvgStdErr().toString());
        measuresValues.add(String.valueOf(measures.getLevel1Count()));
        measuresValues.add(String.valueOf(measures.getLevel2Count()));
        measuresValues.add(String.valueOf(measures.getLevel3Count()));
        if (!IAB.code().equals(asmtTypeCode)) {
            measuresValues.add(String.valueOf(measures.getLevel4Count()));
            measuresValues.add(String.valueOf(measures.getLevel5Count()));
            measuresValues.add(String.valueOf(measures.getLevel6Count()));
        }
        return measuresValues;
    }

    /**
     * @return measures related csv headers with the prefix included into the field names
     */
    protected final List<String> getMeasureHeaders(final Q query, final String prefix) {
        final List<String> headers = newArrayList();
        headers.add(getMessage("report.aggregate.export.header." + prefix + "student-count"));
        headers.add(getMessage("report.aggregate.export.header." + prefix + "score"));
        headers.add(getMessage("report.aggregate.export.header." + prefix + "standard-deviation"));
        headers.addAll(getPerformanceLevelHeaders(query, prefix));
        return headers;
    }

    private static void appendAttribute(final List<String> attributes, final String label, final Collection<String> values) {
        if (values.isEmpty()) return;

        attributes.add(label + ": " + AttributeValueJoiner.join(values));
    }

    protected String getMessage(final String key) {
        return messageSource.getMessage(key, EmptyObjectArray, ReportLocale);
    }

    private void printCsv(final Iterator<R> results, final Q query, final OutputStream outputStream) {
        final List<String> headers = getHeaders(query);
        final CSVFormat csvFormat = CSVFormat.DEFAULT
                .withHeader(headers.toArray(new String[headers.size()]));

        try {
            final CSVPrinter printer = csvFormat.print(new OutputStreamWriter(outputStream, Charsets.UTF_8));
            final CsvContext context = new CsvContext(query);

            while (results.hasNext()) {
                final R result = results.next();
                final List<String> rowValues = getRowValues(context, result);
                printer.printRecord(rowValues);

                context.nextRowIdx();
            }

            printer.flush();
        } catch (final IOException e) {
            logger.warn("Problem exporting report CSV", e);
            throw new RuntimeException(e);
        }
    }

    private List<String> getPerformanceLevelHeaders(final Q query, @NotNull final String prefix) {
        final List<String> performanceLevelHeaders = newArrayList();
        if (IAB.code().equals(query.getAssessmentTypeCode())) {
            for (int i = 1; i <= 3; i++) {
                //this should not happen for IABs
                if (!prefix.isEmpty()) throw new IllegalStateException("invalid invocation for iab");
                performanceLevelHeaders.add(getMessage("report.iab.level." + prefix + i + ".label"));
            }
        } else {
            for (int i = 1; i <= AssessmentBoundaries.MaxPerformanceLevels; i++) {
                performanceLevelHeaders.add(getMessage("report.generic.performance-level." + prefix + i + ".label"));
            }
        }
        return performanceLevelHeaders;
    }

    /**
     * Represents common data across all rows; allows for passing the query as well as cached data from row to row
     */
    protected class CsvContext {
        private final Q query;
        private final AtomicInteger rowIdx = new AtomicInteger(0);
        private final Map<String, Object> store = newHashMap();

        public CsvContext(final Q query) {
            this.query = query;
        }

        public Q getQuery() {
            return query;
        }

        public int getRowIdx() {
            return rowIdx.get();
        }

        private void nextRowIdx() {
            rowIdx.incrementAndGet();
        }

        public void put(final String key, final Object value) {
            store.put(key, value);
        }

        public <T> T get(final String key, final Class<T> clazz) {
            return store.containsKey(key) ? clazz.cast(store.get(key)) : null;
        }
    }
}
