package org.opentestsystem.rdw.reporting.processor.service;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.ExportExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.repository.ExamRepository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.common.test.support.PermissionScopes.statewide;
import static org.opentestsystem.rdw.reporting.processor.test.support.UserTestBuilder.individual;
import static org.opentestsystem.rdw.reporting.processor.test.support.UserTestBuilder.user;

@RunWith(MockitoJUnitRunner.class)
public class ArchiveExamExportServiceTest {
    @Mock
    private ExamRepository repository;

    @Mock
    private ArchiveService archiveService;

    private ArchiveExamExportService examExportService;
    private final User validUser = individual(statewide());
    private final User emptyPermissions = user();

    // service builds a report filename using the report id
    private final String FileName = "export-exam-1.csv";
    private final String RelativePath = ArchiveExamExportService.ExportBasePath + FileName;

    @Before
    public void setup() {
        examExportService = new ArchiveExamExportService(repository, archiveService);
    }

    private void setupFileArchiveTest() {
        when(archiveService.getRawUri(RelativePath))
                .thenReturn("file://" + RelativePath);

        when(repository.export(any(PermissionSource.class), any(ExportExamReportRequest.class), anyString()))
                .thenAnswer((Answer<String>) invocationOnMock -> (String) invocationOnMock.getArguments()[2]);
    }

    private void setupS3ArchiveTest() {
        when(archiveService.getRawUri(RelativePath))
                .thenReturn("s3://bucket/" + RelativePath);

        when(repository.export(any(PermissionSource.class), any(ExportExamReportRequest.class), anyString()))
                .thenAnswer((Answer<String>) invocationOnMock -> invocationOnMock.getArguments()[2] + ".part_0000");
    }

    @Test
    public void itShouldReturnFileRelativeLocation() {
        setupFileArchiveTest();
        assertThat(examExportService.exportExams(validUser, new ExportExamReportRequest(), 1).toASCIIString())
                .isEqualToIgnoringCase(RelativePath);
    }

    @Test
    public void itShouldPassQueryAndTrimFileSchemaWhenCallingRepo() {
        setupFileArchiveTest();

        final ExportExamReportRequest query = new ExportExamReportRequest();

        assertThat(examExportService.exportExams(validUser, query, 1).toASCIIString())
                .isEqualToIgnoringCase(RelativePath);
        verify(repository).export(validUser, query, "/" + RelativePath);
    }

    @Test
    public void itShouldNotTrimS3SchemaWhenPassingToRepo() {
        setupS3ArchiveTest();

        final ExportExamReportRequest query = new ExportExamReportRequest();

        assertThat(examExportService.exportExams(validUser, query, 1).toASCIIString())
                .isEqualToIgnoringCase(RelativePath + ".part_0000");
        verify(repository).export(validUser, query, "s3://bucket/" + RelativePath);
    }

    @Test
    public void itShouldPassEmptyPermissionScopeWhenUserPermissionsIsEmpty() {
        setupFileArchiveTest();

        final ExportExamReportRequest query = new ExportExamReportRequest();

        assertThat(examExportService.exportExams(emptyPermissions, query, 1).toASCIIString())
                .isEqualToIgnoringCase(RelativePath);
        verify(repository).export(emptyPermissions, query, "/" + RelativePath);
    }

}
