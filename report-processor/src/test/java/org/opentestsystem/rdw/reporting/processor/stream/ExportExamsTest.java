package org.opentestsystem.rdw.reporting.processor.stream;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.ExportExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.service.ExamExportService;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import java.net.URI;
import java.util.Collections;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ExportExamsTest {

    private ExportExams component;

    @Mock
    private ExamExportService exportService;

    @Mock
    private ReportService reportService;

    @Mock
    private MessageSecurityService messageSecurityService;

    private final ReportRequestMessage payload = ReportRequestMessage
            .builder()
            .reportId(1L)
            .build();

    private final Message<ReportRequestMessage> message = MessageBuilder
            .createMessage(payload, new MessageHeaders(Collections.emptyMap()));

    private final Report report = Report
            .builder()
            .id(1L)
            .status(ReportStatus.PENDING)
            .reportRequest(new ExportExamReportRequest())
            .build();

    @Before
    public void setup() {
        final User mockUser = mock(User.class);
        when(messageSecurityService.getUser(any(Message.class))).thenReturn(mockUser);
        component = new ExportExams(exportService, reportService, messageSecurityService);
    }

    @Test
    public void itShouldUpdateReportLocationUriAfterExport() {
        final URI exportUri = URI.create("EXPORT/EXAMS/test.csv");

        when(exportService.exportExams(any(User.class), any(ExportExamReportRequest.class), anyLong()))
                .thenAnswer(x -> exportUri);

        when(reportService.findOneById(1L))
                .thenAnswer(x -> Optional.of(report));

        final ArgumentCaptor<Report> reportCaptor = ArgumentCaptor.forClass(Report.class);
        when(reportService.update(reportCaptor.capture())).thenReturn(new Report());

        component.exportExams(message);

        final Report actual = reportCaptor.getValue();

        assertThat(actual.getStatus()).isEqualTo(ReportStatus.COMPLETED);
        assertThat(actual.getReportResourceUri()).isEqualTo(exportUri);
    }

    @Test
    public void itShouldNotTouchAFailedReport() {
        when(reportService.findOneById(1L))
                .thenAnswer(x -> Optional.of(Report.builder().status(ReportStatus.FAILED).build()));

        component.exportExams(message);
        verify(reportService, times(0)).update(any(Report.class));
    }

    @Test(expected=IllegalArgumentException.class)
    public void itShouldThrowIfReportIsNull() {
        when(reportService.findOneById(1L))
                .thenAnswer(x -> Optional.empty());

        component.exportExams(message);
    }
}
