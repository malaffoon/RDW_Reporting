package org.opentestsystem.rdw.reporting.i18n;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.dataformat.javaprop.JavaPropsMapper;
import com.fasterxml.jackson.dataformat.javaprop.JavaPropsParser;
import com.fasterxml.jackson.dataformat.javaprop.JavaPropsSchema;
import com.google.common.io.Resources;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import org.opentestsystem.rdw.reporting.common.i18n.TranslationProvider;
import org.opentestsystem.rdw.reporting.common.multitenant.TenantCacheable;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;

/**
 * This TranslationJsonService provides a json representation of translation key-value pairs
 * using a TranslationProvider.
 * Since our translations are provided as a flat map of "some.prop.path=some_value"
 * we need to transform the flat properties into a hierarchical structure for proper
 * JSON representation using a Jackson JavaPropsMapper .
 */
@Service
class TranslationProviderBackedTranslationJsonService implements TranslationJsonService {
    private static final Logger logger = LoggerFactory.getLogger(TranslationProviderBackedTranslationJsonService.class);

    private final TranslationProvider translationProvider;
    private final JavaPropsMapper propsMapper;
    private final JavaPropsSchema schema;

    public TranslationProviderBackedTranslationJsonService(final TranslationProvider translationProvider) {
        this.translationProvider = translationProvider;
        this.propsMapper = new JavaPropsMapper();
        this.schema = new JavaPropsSchema()
                .withParseSimpleIndexes(false);
    }

    @Override
    @TenantCacheable(value = "translation_properties")
    public ObjectNode getLocaleMessages(final Locale locale, final boolean includeUI) {
        final Map<String, String> translationMessages = newHashMap(translationProvider.getTranslationsByCode(locale));
        if (includeUI) {
            final Properties uiMessages = getUIMessages(locale);
            uiMessages.forEach((key, value) -> translationMessages.putIfAbsent(key.toString(), value.toString()));
        }
        try {
            final String messages = propsMapper.writeValueAsString(translationMessages);
            final JavaPropsParser parser = (JavaPropsParser) propsMapper.getFactory().createParser(messages);
            parser.setSchema(schema);
            final ObjectNode node = propsMapper.readTree(parser);
            orderNode(node);
            return node;
        } catch (final IOException e) {
            logger.warn("Unable to convert translation messages to JSON", e);
            return propsMapper.createObjectNode();
        }
    }

    private void orderNode(final JsonNode node) {
        if (!node.isObject()) return;

        final ObjectNode objectNode = (ObjectNode) node;
        final List<String> children = newArrayList(objectNode.fieldNames());
        children.sort(Comparator.naturalOrder());
        for (final String child : children) {
            final JsonNode childNode = objectNode.remove(child);
            orderNode(childNode);
            objectNode.set(child, childNode);
        }
    }

    private Properties getUIMessages(final Locale locale) {
        final String location = "static/assets/i18n/" + locale.getLanguage() + ".json";
        try {
            final URL resource = Resources.getResource(location);

            try (final InputStream uiTranslationData = resource.openStream()) {
                final ObjectNode root = (ObjectNode) new ObjectMapper().readTree(uiTranslationData);
                return new JavaPropsMapper().writeValueAsProperties(root);
            }
        } catch (final IllegalArgumentException|IOException notFound) {
            return new Properties();
        }
    }
}
