package org.opentestsystem.rdw.reporting.security.auth;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import org.opentestsystem.rdw.reporting.security.GroupGrant;
import org.opentestsystem.rdw.reporting.security.Permission;
import org.opentestsystem.rdw.reporting.security.PermissionScope;
import org.opentestsystem.rdw.reporting.security.Authorities;
import org.opentestsystem.rdw.security.Grant;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.opentestsystem.rdw.security.service.PermissionServiceException;
import org.opentestsystem.rdw.security.support.Grants;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.ImmutableMap.toImmutableMap;
import static com.google.common.collect.Sets.newLinkedHashSet;

@Service
public class DefaultAuthorizationService implements AuthorizationService {

    private final String stateId;
    private final PermissionService permissionService;
    private final DistrictRepository districtRepository;
    private final InstitutionRepository institutionRepository;
    private final GroupGrantRepository groupMembershipRepository;

    @Autowired
    public DefaultAuthorizationService(
            final @NotNull @Value("${application.state}") String stateId,
            final @NotNull @Qualifier("cachingPermissionService") PermissionService permissionService,
            final @NotNull DistrictRepository districtRepository,
            final @NotNull InstitutionRepository institutionRepository,
            final @NotNull GroupGrantRepository groupMembershipRepository) {
        this.stateId = stateId;
        this.permissionService = permissionService;
        this.districtRepository = districtRepository;
        this.institutionRepository = institutionRepository;
        this.groupMembershipRepository = groupMembershipRepository;
    }

    public Set<Grant> getGrants(final String[] encodedGrants) {
        final Set<Grant> grants = newLinkedHashSet();
        for (String encodedGrant : encodedGrants) {
            final Grant grant = Grants.from(encodedGrant);

            // Do not add do not belong to the application instance's state
            if (stateId.equals(grant.getStateId())) {
                grants.add(grant);
            }
        }
        return ImmutableSet.copyOf(grants);
    }

    public Set<Permission> getPermissions(final Collection<? extends Grant> grants) {

        // Groups grants by role to later combine their districts and institutions into a single scope
        // This is to cover the case of multiple non-intersecting grants being given
        // (e.g. roleA,stateA,districtA and roleA,stateA,districtB)
        final Multimap<String, Grant> grantsByRole = Multimaps.index((Iterable<Grant>) grants, Grant::getRole);
        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();


        final Set<String> districtNaturalIds = newLinkedHashSet();
        final Set<String> institutionNaturalIds = newLinkedHashSet();
        for (Grant grant : grants) {
            if (grant.getEntityLevel() == Grant.EntityLevel.DISTRICT) {
                districtNaturalIds.add(grant.getEntityId());
            } else {
                institutionNaturalIds.add(grant.getEntityId());
            }
        }
        final Map<String, Long> districtIds = districtRepository.findAllIds(districtNaturalIds);
        final Map<String, Long> institutionIds = institutionRepository.findAllIds(institutionNaturalIds);

        final Set<Permission> permissions = newLinkedHashSet();

        // Identify and store the permissions associated with the role
        for (String role : grantsByRole.keySet()) {

            final Collection<String> permissionIds = permissionsByRole.get(role);

            // User may have roles not registered to this application in the permission service.
            if (permissionIds != null) {
                for (String permissionId : permissionIds) {
                    permissions.add(
                            new Permission(
                                    permissionId,
                                    createScope(grantsByRole.get(role), districtIds, institutionIds)
                            )
                    );
                }
            }
        }
        return ImmutableSet.copyOf(permissions);
    }

    public Set<GrantedAuthority> getAuthorities(final Collection<? extends Grant> grants) {
        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();
        final ImmutableSet.Builder<GrantedAuthority> authorities = ImmutableSet.builder();
        for (Grant grant : grants) {
            if (grant.getEntityLevel() == Grant.EntityLevel.STATE) {
                if (permissionsByRole.containsKey(grant.getRole())) {
                    authorities.add(Authorities.createRole(grant.getRole()));
                    final Collection<String> permissionIds = permissionsByRole.get(grant.getRole());
                    if (permissionIds != null) {
                        for (String permission : permissionIds) {
                            authorities.add(Authorities.createPermission(permission));
                        }
                    }
                }
            }
        }
        return authorities.build();
    }

    public Map<Long, GroupGrant> getGroupsById(final Collection<? extends Permission> permissions, final String username) {
        // only lookup groups for those with the group PII permission
        if (permissions.stream().noneMatch(permission -> permission.getId().equals("GROUP_PII_READ"))) {
            return ImmutableMap.of();
        }
        return groupMembershipRepository.findAllForUsername(username).stream()
                .collect(toImmutableMap(GroupGrant::getId, group -> group));
    }

    private Map<String, Collection<String>> getPermissionsByRole() {
        try {
            return permissionService.getPermissionsByRole();
        } catch (PermissionServiceException exception) {
            throw new RuntimeException("Failed to get permissions", exception);
        }
    }

    private PermissionScope createScope(
            final Collection<Grant> grantsWithSameRole,
            final Map<String, Long> districtIdByNaturalId,
            final Map<String, Long> institutionIdByNaturalId) {

        if (grantsWithSameRole.size() == 1) {
            return createScope(
                    grantsWithSameRole.iterator().next(),
                    districtIdByNaturalId,
                    institutionIdByNaturalId
            );
        }

        // Below implementation assumes if there was a state-level role,
        // all other scopes for the same role are contained in that role and therefore already filtered out
        // and there should only be one scope left for this role
        final ImmutableSet.Builder<Long> districtIds = ImmutableSet.builder();
        final ImmutableSet.Builder<Long> institutionIds = ImmutableSet.builder();

        for (Grant grant : grantsWithSameRole) {
            if (grant.getEntityLevel() == Grant.EntityLevel.DISTRICT) {
                districtIds.add(districtIdByNaturalId.get(grant.getEntityId()));
            } else {
                institutionIds.add(institutionIdByNaturalId.get(grant.getEntityId()));
            }
        }

        return new PermissionScope(districtIds.build(), institutionIds.build());
    }

    private PermissionScope createScope(
            final Grant grant,
            final Map<String, Long> districtIdByNaturalId,
            final Map<String, Long> institutionIdByNaturalId) {

        if (grant.getEntityLevel() == Grant.EntityLevel.STATE) {
            return PermissionScope.STATEWIDE;
        }
        if (grant.getEntityLevel() == Grant.EntityLevel.DISTRICT) {
            return new PermissionScope(
                    ImmutableSet.of(districtIdByNaturalId.get(grant.getEntityId())),
                    ImmutableSet.of()
            );
        }
        return new PermissionScope(
                ImmutableSet.of(),
                ImmutableSet.of(institutionIdByNaturalId.get(grant.getEntityId()))
        );

    }
}
