package org.opentestsystem.rdw.reporting.security.authority;

import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.reporting.common.security.ReportingRole;
import org.opentestsystem.rdw.reporting.sandbox.SandboxRole;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.opentestsystem.rdw.security.repository.OrganizationRepository;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.opentestsystem.rdw.security.service.PermissionServiceException;
import org.opentestsystem.rdw.utils.Grant;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static java.util.Collections.emptySet;
import static java.util.stream.Collectors.toSet;
import static org.opentestsystem.rdw.reporting.common.security.ReportingRole.ReportingRoles;
import static org.opentestsystem.rdw.reporting.security.authority.Authorities.toAuthority;
import static org.opentestsystem.rdw.utils.Grant.Level.DISTRICT;
import static org.opentestsystem.rdw.utils.Grant.Level.DISTRICT_GROUP;
import static org.opentestsystem.rdw.utils.Grant.Level.INSTITUTION;
import static org.opentestsystem.rdw.utils.Grant.Level.INSTITUTION_GROUP;

@Service
class DefaultAuthorityService implements AuthorityService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAuthorityService.class);

    private final TenantProperties tenantProperties;
    private final PermissionService permissionService;
    private final OrganizationRepository organizationRepository;

    @Autowired
    DefaultAuthorityService(
            final TenantProperties tenantProperties,
            final @Qualifier("cachingPermissionService") PermissionService permissionService,
            final OrganizationRepository organizationRepository) {
        this.tenantProperties = tenantProperties;
        this.permissionService = permissionService;
        this.organizationRepository = organizationRepository;
    }

    @Override
    public Set<Authority> getAuthorities(final SandboxRole role) {
        switch (role.getType()) {
            case DistrictAdministrator:
                return createAuthorities(
                        role.getOrganization().getNaturalId(),
                        DISTRICT,
                        ReportingRole.Pii,
                        ReportingRole.GroupAdmin,
                        ReportingRole.CustomAggregateReporter,
                        ReportingRole.EmbargoAdmin,
                        ReportingRole.InstructionalResourceAdmin
                );
            case SchoolAdministrator:

                return createAuthorities(
                        role.getOrganization().getNaturalId(),
                        INSTITUTION,
                        ReportingRole.Pii,
                        ReportingRole.CustomAggregateReporter
                );
            case Teacher:
                return createAuthorities(
                        role.getOrganization().getNaturalId(),
                        INSTITUTION,
                        ReportingRole.PiiGroup
                );
        }
        return emptySet();
    }

    @Override
    public Set<Authority> getAuthorities(final String[] encodedGrants) {
        final Set<Authority> authorities = newHashSet();
        String stateId = null;
        for (final String encodedGrant : encodedGrants) {
            try {
                final Authority authority = toAuthority(Grant.fromString(encodedGrant));
                // skip grants for roles reporting doesn't care about
                if (!ReportingRoles.contains(authority.getRole())) {
                    continue;
                }
                // skip grants for unknown states or those that don't match the first state found
                if (authority.getStateId() != null) {
                    if (!tenantProperties.findTenantById(authority.getStateId()).isPresent()) {
                        continue;
                    }
                    if (stateId == null) {
                        stateId = authority.getStateId();
                    } else if (!stateId.equals(authority.getStateId())) {
                        continue;
                    }
                }
                authorities.add(authority);
            } catch (final IllegalArgumentException exception) {
                // in a well-behaved and properly configured ecosystem this should never happen
                // so log a WARN level message so the log may be monitored
                logger.warn("invalid grant: {}", encodedGrant);
            }
        }
        return authorities;
    }

    // A Grant is a role granted for a state or organization identified by its natural id.
    // A Permission is a permission and collection of organizations identified by their internal ids.
    // This method maps the grant roles to the associated permissions, collects and dedups the
    // organizations that share that permission, and resolves natural ids to internal ids.
    @Override
    public Set<Permission> getPermissions(final Collection<Authority> authorities) {

        // Groups grants by role to later combine their districts and institutions into a single scope
        // This is to cover the case of multiple non-intersecting grants being given
        // (e.g. roleA,stateA,districtA and roleA,stateA,districtB)
        final Multimap<String, Authority> authoritiesByRole = Multimaps.index(authorities, Authority::getRole);
        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();

        final Map<String, Long> districtGroupIdsByNaturalId = organizationRepository.findAllDistrictGroupIds(authorities.stream()
                .filter(grant -> grant.getLevel() == DISTRICT_GROUP)
                .map(Authority::getEntityId).collect(toSet()));
        final Map<String, Long> districtIdsByNaturalId = organizationRepository.findAllDistrictIds(authorities.stream()
                .filter(grant -> grant.getLevel() == DISTRICT)
                .map(Authority::getEntityId).collect(toSet()));
        final Map<String, Long> schoolGroupIdsByNaturalId = organizationRepository.findAllSchoolGroupIds(authorities.stream()
                .filter(grant -> grant.getLevel() == INSTITUTION_GROUP)
                .map(Authority::getEntityId).collect(toSet()));
        final Map<String, Long> schoolIdsByNaturalId = organizationRepository.findAllSchoolIds(authorities.stream()
                .filter(grant -> grant.getLevel() == INSTITUTION)
                .map(Authority::getEntityId).collect(toSet()));

        // Identify and store the permissions associated with the role
        final Map<String, PermissionScope.Builder> permissionScopeBuildersByPermissionId = newHashMap();
        for (Map.Entry<String, Authority> entry : authoritiesByRole.entries()) {

            final Collection<String> permissionIds = permissionsByRole.get(entry.getKey());

            // The user may be granted roles that are not registered to this application in the permission configuration.
            // These roles should be ignored as they do not apply to our application
            if (permissionIds == null) continue;

            final Authority authority = entry.getValue();
            for (final String permissionId : permissionIds) {
                final PermissionScope.Builder permissionScopeBuilder = permissionScopeBuildersByPermissionId
                        .computeIfAbsent(permissionId, (key) -> PermissionScope.builder());

                switch (authority.getLevel()) {
                    case STATE:
                        permissionScopeBuilder.statewide(true);
                        break;
                    case DISTRICT_GROUP:
                        addDistrictGroup(permissionScopeBuilder, authority.getEntityId(), districtGroupIdsByNaturalId);
                        break;
                    case DISTRICT:
                        addDistrict(permissionScopeBuilder, authority.getEntityId(), districtIdsByNaturalId);
                        break;
                    case INSTITUTION_GROUP:
                        addSchoolGroup(permissionScopeBuilder, authority.getEntityId(), schoolGroupIdsByNaturalId);
                        break;
                    case INSTITUTION:
                        addSchool(permissionScopeBuilder, authority.getEntityId(), schoolIdsByNaturalId);
                        break;
                    case CLIENT:
                    case STATE_GROUP:
                    default:
                        break;
                }
            }
        }

        return permissionScopeBuildersByPermissionId.entrySet().stream()
                // missing IDs in the natural ID to entity ID map can result in an invalid permission scope builder
                // that is neither statewide nor containing any schools and districts so this will filter those out
                .filter(entry -> entry.getValue().isValid())
                .map(entry -> new Permission(entry.getKey(), entry.getValue().build()))
                .collect(toSet());
    }

    private Map<String, Collection<String>> getPermissionsByRole() {
        try {
            return permissionService.getPermissionsByRole();
        } catch (PermissionServiceException exception) {
            throw new RuntimeException("Failed to get permissions", exception);
        }
    }

    private void addDistrictGroup(final PermissionScope.Builder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addDistrictGroupId(id);
        } else {
            logger.warn("grant district group with natural ID \"{}\" not found", entityId);
        }
    }

    private void addDistrict(final PermissionScope.Builder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addDistrictId(id);
        } else {
            logger.warn("grant district with natural ID \"{}\" not found", entityId);
        }
    }

    private void addSchoolGroup(final PermissionScope.Builder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addSchoolGroupId(id);
        } else {
            logger.warn("grant school group with natural ID \"{}\" not found", entityId);
        }
    }

    private void addSchool(final PermissionScope.Builder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addSchoolId(id);
        } else {
            logger.warn("grant school with natural ID \"{}\" not found", entityId);
        }
    }

    private Set<Authority> createAuthorities(
            final String entityId,
            final Grant.Level level,
            final String... reportingRoles) {
        return Arrays.stream(reportingRoles)
                .map(role ->
                        Authority.builder()
                                .role(role)
                                .level(level)
                                .entityId(entityId)
                                .build()
                )
                .collect(toSet());
    }

}
