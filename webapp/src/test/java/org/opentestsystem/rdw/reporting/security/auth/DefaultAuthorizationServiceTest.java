package org.opentestsystem.rdw.reporting.security.auth;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.security.GroupGrant;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.opentestsystem.rdw.security.repository.OrganizationRepository;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.opentestsystem.rdw.utils.Grant;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.GroupPiiRead;

@RunWith(SpringRunner.class)
@ActiveProfiles("test")
public class DefaultAuthorizationServiceTest {

    private static final String stateA = "stateA";

    @MockBean
    private PermissionService permissionService;

    @MockBean
    private OrganizationRepository organizationRepository;

    @MockBean
    private GroupGrantRepository groupMembershipRepository;

    private DefaultAuthorizationService authorizationService;

    @Before
    public void before() throws Exception {
        authorizationService = new DefaultAuthorizationService(
                stateA,
                permissionService,
                organizationRepository,
                groupMembershipRepository
        );

        when(permissionService.getPermissionsByRole()).thenReturn(ImmutableMap.of(
                "a", ImmutableSet.of("a"),
                "b", ImmutableSet.of("b"),
                "c", ImmutableSet.of("c"),
                "d", ImmutableSet.of("d", "f"),
                "e", ImmutableSet.of()
        ));
        when(organizationRepository.findAllDistrictGroupIds(ImmutableSet.of("a"))).thenReturn(ImmutableMap.of("a", 1L));
        when(organizationRepository.findAllDistrictIds(ImmutableSet.of("a"))).thenReturn(ImmutableMap.of("a", 1L));
        when(organizationRepository.findAllSchoolGroupIds(ImmutableSet.of("a"))).thenReturn(ImmutableMap.of("a", 1L));
        when(organizationRepository.findAllSchoolIds(ImmutableSet.of("a"))).thenReturn(ImmutableMap.of("a", 1L));
        when(groupMembershipRepository.findAllForUsername("a")).thenReturn(ImmutableList.of(new GroupGrant(1L, 1)));
    }

    @Test
    public void getGrantsShouldIgnoreInvalidEntityLevels() throws Exception {
        final String[] encodedGrants = {"|something|roleA|invalid|||||||||||||||"};
        assertThat(authorizationService.getGrants(encodedGrants)).isEmpty();
    }

    @Test
    public void getGrantsShouldIgnoreGrantsWithUnsupportedEntityLevel() throws Exception {
        final String[] encodedGrants = {"|districtGroupA|roleA|CLIENT|||||stateA||districtGroupA||||||||", "|schoolGroupA|roleA|STATE_GROUP|||||stateA||||districtA||schoolGroupA||||"};
        assertThat(authorizationService.getGrants(encodedGrants)).isEmpty();
    }

    @Test
    public void getGrantsShouldOnlyIncludeGrantsForTheSpecifiedState() throws Exception {
        final String[] encodedGrants = {"|stateA|roleA|STATE|||||stateA||||||||||", "|stateB|roleA|STATE|||||stateB||||||||||"};
        assertThat(authorizationService.getGrants(encodedGrants))
                .containsExactlyInAnyOrder(
                        Grant.fromString("|stateA|roleA|STATE|||||stateA||||||||||")
                );
    }

    @Test
    public void getPermissionsShouldCorrectlyDerivePermissionsFromGrants() throws Exception {
        final List<Grant> grants = ImmutableList.of(
                Grant.fromString("|a|a|STATE|||||a||"),
                Grant.fromString("|a|b|DISTRICT|||||a||||a||"),
                Grant.fromString("|a|c|INSTITUTION_GROUP|||||a||||a||a||||"),
                Grant.fromString("|a|c|INSTITUTION|||||a||||a||||a||"),
                Grant.fromString("|a|d|DISTRICT|||||a||||a||"),
                Grant.fromString("|a|d|INSTITUTION|||||a||||a||||a||")
        );

        assertThat(authorizationService.getPermissions(grants))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(
                        new Permission("a", PermissionScope.STATEWIDE),
                        new Permission("b", PermissionScope.builder().addDistrictId(1).build()),
                        new Permission("c", PermissionScope.builder().addSchoolGroupId(1).addSchoolId(1).build()),
                        new Permission("d", PermissionScope.builder().addDistrictId(1).addSchoolId(1).build()),
                        new Permission("f", PermissionScope.builder().addDistrictId(1).addSchoolId(1).build())
                );
    }

    @Test
    public void getPermissionsShouldIgnoreOrganizationsForWhichThereIsNoEntityID() throws Exception {
        final List<Grant> grants = ImmutableList.of(
                Grant.fromString("|missing_school|a|INSTITUTION|||||a||||2||||missing_school||"),
                Grant.fromString("|missing_district|a|DISTRICT|||||a||||missing_district||")
        );

        assertThat(authorizationService.getPermissions(grants)).isEmpty();
    }

    @Test
    public void getPermissionsShouldAllowButIgnoreOrganizationsForWhichThereIsNoEntityID() throws Exception {
        final List<Grant> grants = ImmutableList.of(
                Grant.fromString("|a|a|INSTITUTION|||||a||||2||||a||"),
                Grant.fromString("|missing_district|a|DISTRICT|||||a||||missing_district||")
        );

        assertThat(authorizationService.getPermissions(grants))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(
                        new Permission("a", PermissionScope.builder().addSchoolId(1).build())
                );
    }

    @Test
    public void getPermissionsShouldUnionPermissionScopesOfRepeatingPermissions() throws Exception {
        when(organizationRepository.findAllDistrictIds(ImmutableSet.of("2", "4"))).thenReturn(ImmutableMap.of("2", 2L, "4", 4L));
        when(organizationRepository.findAllSchoolIds(ImmutableSet.of("1", "3"))).thenReturn(ImmutableMap.of("1", 1L, "3", 3L));

        final List<Grant> grants = ImmutableList.of(
                Grant.fromString("|1|a|INSTITUTION|||||a||||2||||1||"),
                Grant.fromString("|2|a|DISTRICT|||||a||||2||"),
                Grant.fromString("|3|a|INSTITUTION|||||a||||4||||3||"),
                Grant.fromString("|4|a|DISTRICT|||||a||||4||")
        );

        assertThat(authorizationService.getPermissions(grants))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(
                        new Permission("a", PermissionScope.builder().addDistrictId(2).addDistrictId(4).addSchoolId(1).addSchoolId(3).build())
                );
    }

    @Test
    public void getPermissionsShouldProduceStateLevelPermissionScopeForUnionWithStateLevel() throws Exception {
        final List<Grant> grants = ImmutableList.of(
                Grant.fromString("|a|a|STATE|||||a||"),
                Grant.fromString("|a|a|DISTRICT|||||a||||a||")
        );

        assertThat(authorizationService.getPermissions(grants))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(new Permission("a", PermissionScope.builder().statewide(true).addDistrictId(1).build()));
    }

    @Test
    public void getAuthoritiesShouldReturnAllDespiteEntityLevel() throws Exception {
        assertThat(authorizationService.getAuthorities(ImmutableList.of(
                Grant.fromString("|a|a|STATE|||||a||"),
                Grant.fromString("|a|b|DISTRICT|||||a||||a||"),
                Grant.fromString("|a|c|INSTITUTION|||||a||||a||||a||")
        ))).containsExactlyInAnyOrder(
                new SimpleGrantedAuthority("ROLE_A"),
                new SimpleGrantedAuthority("PERM_A"),
                new SimpleGrantedAuthority("ROLE_B"),
                new SimpleGrantedAuthority("PERM_B"),
                new SimpleGrantedAuthority("ROLE_C"),
                new SimpleGrantedAuthority("PERM_C")
        );
    }

    @Test
    public void getAuthoritiesShouldIgnoreRolesNotProvidedByThePermissionService() throws Exception {
        assertThat(authorizationService.getAuthorities(ImmutableList.of(
                Grant.fromString("|a|z|STATE|||||a||")
        ))).isEmpty();
    }

    @Test
    public void getAuthoritiesShouldNotFailIfThereAreNoPermissionsForAGivenRole() throws Exception {
        assertThat(authorizationService.getAuthorities(ImmutableList.of(
                Grant.fromString("|a|e|STATE|||||a||")
        ))).containsExactlyInAnyOrder(
                new SimpleGrantedAuthority("ROLE_E")
        );
    }

    @Test
    public void getAuthoritiesShouldReturnAllStateLevelRolesAndPermissions() throws Exception {
        assertThat(authorizationService.getAuthorities(ImmutableList.of(
                Grant.fromString("|a|a|STATE|||||a||"),
                Grant.fromString("|a|b|STATE|||||a||"),
                Grant.fromString("|a|c|STATE|||||a||"),
                Grant.fromString("|a|d|STATE|||||a||")
        ))).containsExactlyInAnyOrder(
                new SimpleGrantedAuthority("ROLE_A"),
                new SimpleGrantedAuthority("PERM_A"),
                new SimpleGrantedAuthority("ROLE_B"),
                new SimpleGrantedAuthority("PERM_B"),
                new SimpleGrantedAuthority("ROLE_C"),
                new SimpleGrantedAuthority("PERM_C"),
                new SimpleGrantedAuthority("ROLE_D"),
                new SimpleGrantedAuthority("PERM_D"),
                new SimpleGrantedAuthority("PERM_F")
        );
    }

    @Test
    public void getGroupsByIdShouldReturnEmptyIfTheUserDoesNotHaveGroupPII() throws Exception {
        assertThat(authorizationService.getGroups(ImmutableSet.of(), "a")).isEmpty();
    }

    @Test
    public void getGroupsByIdShouldReturnAllOfTheGroupsAssociatedWithTheUsernameForUsersWithGroupPII() throws Exception {
        assertThat(authorizationService.getGroups(ImmutableSet.of(new Permission(GroupPiiRead, PermissionScope.STATEWIDE)), "a"))
                .containsExactlyInAnyOrder(new GroupGrant(1L, 1));
    }

}