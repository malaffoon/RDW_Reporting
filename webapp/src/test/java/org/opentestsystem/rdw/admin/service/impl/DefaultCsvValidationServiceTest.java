package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.admin.common.model.Organization;
import org.opentestsystem.rdw.admin.common.security.PermissionScope;
import org.opentestsystem.rdw.admin.model.CsvSubject;
import org.opentestsystem.rdw.admin.model.CsvValidationFailure;
import org.opentestsystem.rdw.admin.repository.SchoolRepository;

import java.io.IOException;
import java.io.StringReader;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;
import static org.apache.commons.lang.StringUtils.EMPTY;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.admin.service.impl.DefaultCsvValidationService.HeaderGroup;
import static org.opentestsystem.rdw.admin.service.impl.DefaultCsvValidationService.HeaderSSID;
import static org.opentestsystem.rdw.admin.service.impl.DefaultCsvValidationService.HeaderSchool;
import static org.opentestsystem.rdw.admin.service.impl.DefaultCsvValidationService.HeaderSubject;
import static org.opentestsystem.rdw.admin.service.impl.DefaultCsvValidationService.HeaderYear;
import static org.opentestsystem.rdw.admin.service.impl.DefaultCsvValidationService.MaxStudentsPerGroup;
import static org.opentestsystem.rdw.admin.service.impl.DefaultCsvValidationService.RequiredHeaders;

@RunWith(MockitoJUnitRunner.class)
public class DefaultCsvValidationServiceTest {
    private static final String SchoolA = "SCHOOL_A";
    private static final String SchoolB = "SCHOOL_B";
    private static final String GroupA = "GROUP_A";
    private static final String GroupB = "GROUP_B";
    private static final int SchoolYear = 2017;
    private static final List<String> OrderedHeaders = newArrayList(RequiredHeaders);

    @Mock
    public SchoolRepository schoolRepository;

    private DefaultCsvValidationService service;

    @Before
    public void setup() {
        final List<Organization> schools = newArrayList();
        schools.add(new Organization(1, "School A", SchoolA));
        schools.add(new Organization(2, "School B", SchoolB));
        when(schoolRepository.findAll(PermissionScope.STATEWIDE)).thenReturn(schools);

        service = new DefaultCsvValidationService(schoolRepository);
    }

    @Test
    public void itShouldValidateRequiredHeaders() {
        assertThat(service.validateHeaders(RequiredHeaders)).isEmpty();
    }

    @Test
    public void itShouldNotValidateMissingHeaders() {
        final Set<String> missingHeaders = newHashSet(RequiredHeaders);
        missingHeaders.remove(HeaderSchool);

        final CsvValidationFailure failure = service.validateHeaders(missingHeaders).get(0);

        assertThat(failure.getRow()).isEqualTo(0);
        assertThat(failure.getMessage()).contains(HeaderSchool);
    }

    @Test
    public void itShouldValidateACsvWithSchoolsAndGroupsInOrder() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, GroupB)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.build()) {
            assertThat(service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE)).isEmpty();
        }
    }

    @Test
    public void itShouldNotValidateACsvWithSchoolsOutOfOrder() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB)
                .row(SchoolA, GroupB);

        try (final CSVParser parser = builder.build()) {
            final List<CsvValidationFailure> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);
            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(4);
            assertThat(failures.get(0).getMessage()).contains("out-of-order");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithGroupsOutOfOrder() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, GroupB)
                .row(SchoolA, GroupA)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.build()) {
            final List<CsvValidationFailure> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);
            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(3);
            assertThat(failures.get(0).getMessage()).contains("out-of-order");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithAMissingGroupsPrimaryKeyRecord() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, EMPTY)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.build()) {
            final List<CsvValidationFailure> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);
            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(2);
            assertThat(failures.get(0).getMessage()).contains("group name");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithAnUnknownOrUnauthorizedSchool() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row("UnknownSchool", GroupA)
                .row(SchoolA, GroupB)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.build()) {
            final List<CsvValidationFailure> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);
            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(1);
            assertThat(failures.get(0).getMessage()).contains("UnknownSchool");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithMultipleGroupSubjects() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, GroupB, SchoolYear, CsvSubject.ELA, null)
                .row(SchoolA, GroupB, SchoolYear, CsvSubject.Math, null)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.build()) {
            final List<CsvValidationFailure> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);
            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(3);
            assertThat(failures.get(0).getMessage()).contains("[ELA]", "[Math]");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithMoreThanMaxStudentsPerGroup() throws Exception {
        final RecordBuilder builder = recordBuilder();
        for (int i = 0; i < (MaxStudentsPerGroup + 1); i++) {
            builder.row(SchoolA, GroupA, SchoolYear, CsvSubject.ELA, "Student_" + i);
        }

        try (final CSVParser parser = builder.build()) {
            final List<CsvValidationFailure> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);
            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(MaxStudentsPerGroup + 1);
            assertThat(failures.get(0).getMessage()).contains("Maximum students allowed");
        }
    }

    private static RecordBuilder recordBuilder() {
        return new RecordBuilder();
    }

    private static class RecordBuilder {
        final List<List<String>> records = newArrayList();

        public CSVParser build() {
            try {
                final StringBuilder csvBuilder = new StringBuilder();
                final CSVFormat format = CSVFormat.DEFAULT
                        .withIgnoreHeaderCase()
                        .withFirstRecordAsHeader()
                        .withHeader(OrderedHeaders.toArray(new String[OrderedHeaders.size()]));
                final CSVPrinter printer = new CSVPrinter(csvBuilder, format.withSkipHeaderRecord(false));
                for (final List<String> record : records) {
                    printer.printRecord(record);
                }
                printer.close();

                return new CSVParser(new StringReader(csvBuilder.toString()), format);
            } catch (final IOException e) {
                throw new RuntimeException(e);
            }
        }

        public RecordBuilder row(final String school, final String group) {
            return row(school, group, SchoolYear, null, null);
        }

        public RecordBuilder row(final String school,
                                 final String group,
                                 final int schoolYear,
                                 final CsvSubject subject,
                                 final String studentSSID) {
            final Map<String, String> record = new HashMap<>();
            record.put(HeaderSchool, school);
            record.put(HeaderGroup, group);
            record.put(HeaderYear, String.valueOf(schoolYear));
            record.put(HeaderSubject, subject == null ? null : subject.name());
            record.put(HeaderSSID, studentSSID);

            final List<String> values = newArrayList();
            for (final String header : OrderedHeaders) {
                values.add(record.get(header));
            }
            records.add(values);

            return this;
        }
    }
}